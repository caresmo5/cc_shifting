import pandas as pd
import numpy as np
from datetime import datetime, timedelta, time
import random


# INTENTAR:
#   Podría probar a tener en cuenta la productividad media de cada agente (si lo viera viable, por día de la semana y por horas).
#   A lo mejor sería hacer una tabla con las siguientes columnas: País, Día, Hora, Agente, Productividad.
#   Incluso podría sacar las horas cada 10min y, como sé quién está y quien no a ese detalle, puedo sacar los agentes que hay cada 10 min.
#   Como sé los agentes concretos, sé las contestadas concretas cada 10min (productividad por hora / 6). Sumando todo el día, lo tengo.
#   Para esto podría repetir todas las horas cada 10min tantas veces como agentes haya. Luego poner al lado los agentes repetidos.
#   Luego una columna de 1s. Como sé en qué 10min no está cada agente, hago: si es este agente y esta hora (en la que está descansando),
#   pon un 0. Entonces elimino los 0s de la columna. Para cada agente, sustituyo los 1s por su respectiva productividad.
#   OJO, así lo que estoy diciendo es que cada agente está trabajando de 7h a 22h excepto en sus pausas. Tendría que poner 1s solo en las
#   horas en las que trabajan. Esto ya para más adelante.



planning = pd.read_excel('U:\Turnos\Horarios y pausas\Definitivo\Planning Internacional 2 (prueba de Carlos España para Python).xlsx', sheet_name= 'Hoja1')
planning.iloc[14,9:] = planning.iloc[11,9:]
names = planning.iloc[14]
planning = planning.iloc[15:]
planning.columns = names
planning = planning[planning['País'] == 'ALEMANIA']
planning = planning[(planning['Status'] == 'ALTA') | (planning['Status'] == 'BAJA TEMPORAL')]

inicio = input('¿Desde qué día? (aaaa-mm-dd) ')
inicio = datetime.strptime(inicio,'%Y-%m-%d')
fin = input('¿Hasta qué día? (aaaa-mm-dd) ')
fin = datetime.strptime(fin,'%Y-%m-%d')

definitivo = {'Línea': [],
         'Nombre': [],
         'Turno': [],
         'Agente': [],
         'Preferencia': [],
         'Pref. Texto': [],
         'Subturno': [],
         'Tipo de pausa': [],
         'Hora': [],
         'Pais': [],
         'Dia': []}

definitivo = pd.DataFrame(definitivo)

prevision = {'Dia': [],
         'Pais': [],
         'Hora': [],
         'Agentes': [],
         'Productividad': [],
         'Contestadas': [],
         'Recibidas': [],
         'Accesibilidad sin limitar': [],
         'Accesibilidad limitada': []}

prevision = pd.DataFrame(prevision)


def pausas(dia,planning,definitivo,prevision):
    planning = planning[['Línea', 'Nombre', dia]]
    planning[dia] = planning[dia].astype(str)
    planning = planning.dropna(axis=0, subset=[dia])
    planning = planning[planning[dia] != 'V']
    planning = planning[planning[dia] != 'B']
    planning = planning[planning[dia] != 'P']
    planning = planning[planning[dia] != 'F']
    planning = planning[planning[dia] != 'Li']
    planning = planning[planning[dia] != 'LI']
    planning = planning[planning[dia] != 'EJ']
    planning = planning[planning[dia] != '0']
    planning = planning.sort_values(by=dia)


    preferencias = pd.read_excel('U:\Turnos\Horarios y pausas\Definitivo\Preferencias.xlsx')
    preferencias.rename(columns={'Nombre':'Agente','Agente':'Nombre'}, inplace=True)
    planning = planning.merge(preferencias, on = 'Nombre')

    forecast = pd.read_excel('U:\Turnos\Horarios y pausas\Definitivo\Forecast.xlsx')
    names = ['Hora']
    names[1:368] = pd.date_range(datetime.strptime('2024-01-01','%Y-%m-%d'), periods=366).tolist()
    forecast.columns = names
    forecast = forecast[dia]
    forecast = forecast.values

    turnossin = pd.read_excel('U:\Turnos\Horarios y pausas\Definitivo\Turnos.xlsx', sheet_name='Sin pausas')

    horas = turnossin.iloc[:,0]

    nombreturnossin = turnossin.columns
    nombreturnossin = nombreturnossin[1:]
    frecuencia = [0,0,0,0,0,0,0,0,0,0]
    frecuencia[0] = planning[dia].value_counts().get('M7',0) + planning[dia].value_counts().get('M7*',0)
    frecuencia[1] = planning[dia].value_counts().get('M8',0) + planning[dia].value_counts().get('M8*',0)
    frecuencia[2] = planning[dia].value_counts().get('M9',0) + planning[dia].value_counts().get('M9*',0)
    frecuencia[3] = planning[dia].value_counts().get('M10',0) + planning[dia].value_counts().get('M10*',0)
    frecuencia[4] = planning[dia].value_counts().get('P9:00',0)
    frecuencia[5] = planning[dia].value_counts().get('P9:30',0)
    frecuencia[6] = planning[dia].value_counts().get('M12',0) + planning[dia].value_counts().get('M12*',0)
    frecuencia[7] = planning[dia].value_counts().get('T13',0) + planning[dia].value_counts().get('T13*',0)
    frecuencia[8] = planning[dia].value_counts().get('T14',0) + planning[dia].value_counts().get('T14*',0) + planning[dia].value_counts().get('*T14',0)
    frecuencia[9] = planning[dia].value_counts().get('M9:30',0) + planning[dia].value_counts().get('M9:30*',0)
    contador = np.array(frecuencia)

    turnossin = turnossin.drop(turnossin.columns[0],axis=1)
    turnossin = turnossin.values

    agentes = np.dot(turnossin,contador)

    productividad = 4.5
    tope_accesibilidad = 0.97

    contestadas = agentes * productividad
    contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad

    accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
    accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

    acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
    acc.iloc[:,0] = horas
    acc.iloc[:,1] = accesibilidad


    turnoscon = pd.read_excel('U:\Turnos\Horarios y pausas\Definitivo\Turnos.xlsx', sheet_name='Con pausas')
    pausas = turnoscon[32:35]


    # Ordeno los agentes por líneas para intentar que los que tengan las mismas líneas coindidan lo mínimo en las pausas
    planning = planning.sort_values(by=['Línea',dia])

    CP = planning[planning['Línea'].isin(['CP',' CP','  CP','CP ','CP  '])]
    RP = planning[planning['Línea'].isin(['RP',' RP','  RP','RP ','RP  '])]
    SP = planning[planning['Línea'].isin(['SP',' SP','  SP','SP ','SP  '])]
    RPAT = planning[planning['Línea'].isin(['RP/AT-RP',' RP/AT-RP','  RP/AT-RP','RP/AT-RP ','RP/AT-RP  '])]
    RPCP = planning[planning['Línea'].isin(['RP/CP',' RP/CP','  RP/CP','RP/CP ','RP/CP  '])]
    RPSP = planning[planning['Línea'].isin(['RP/SP',' RP/SP','  RP/SP','RP/SP ','RP/SP  '])]
    RPSPCP = planning[planning['Línea'].isin(['RP/SP/CP',' RP/SP/CP','  RP/SP/CP','RP/SP/CP ','RP/SP/CP  '])]
    SPCP = planning[planning['Línea'].isin(['SP/CP',' SP/CP','  SP/CP','SP/CP ','SP/CP  '])]

    planning = planning.assign(Subturno = np.zeros((len(planning['Nombre']),1)))
    planning = planning.assign(Lunch = np.zeros((len(planning['Nombre']),1)))

    orden = pd.read_excel('Orden horas.xlsx')

    #CP
    for i in range(len(planning['Nombre'])):
        CP = planning[planning['Línea'].isin(['CP',' CP','  CP','CP ','CP  '])]
        if planning.iloc[i,2] == 'M7' and planning.iloc[i,5] == "10'-30'-10'" and (planning.iloc[i,0] == 'CP' or planning.iloc[i,0] == ' CP' or planning.iloc[i,0] == '  CP' or planning.iloc[i,0] == 'CP ' or planning.iloc[i,0] == 'CP  '):
            cantidad = CP[dia].value_counts().get('M7',0)
            horas_dispo = pausas.loc[[33],['M7.1','M7.2','M7.3','M7.4','M7.5']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M7.1','M7.2','M7.3','M7.4','M7.5'])

            m71 = CP['Subturno'].value_counts().get('M7.1', 0)
            m72 = CP['Subturno'].value_counts().get('M7.2', 0)
            m73 = CP['Subturno'].value_counts().get('M7.3', 0)
            m74 = CP['Subturno'].value_counts().get('M7.4', 0)        
            m75 = CP['Subturno'].value_counts().get('M7.5', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m71,m72,m73,m74,m75])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
            planning.iloc[i,6] = maximo.loc['Subturno']
            planning.iloc[i,7] = maximo.loc['Hora']     

            posicion = maximo.loc['Hora']
            posicion = orden[orden['Hora'] == posicion]
            posicion = posicion.iloc[0,1]
            agentes[posicion] = agentes[posicion] - 1

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad

        if planning.iloc[i,2] == 'M8' and (planning.iloc[i,0] == 'CP' or planning.iloc[i,0] == ' CP' or planning.iloc[i,0] == '  CP' or planning.iloc[i,0] == 'CP ' or planning.iloc[i,0] == 'CP  '):
            cantidad = CP[dia].value_counts().get('M8',0)
            horas_dispo = pausas.loc[[33],['M8.1','M8.2','M8.3','M8.4','M8.5']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M8.1','M8.2','M8.3','M8.4','M8.5'])

            m81 = CP['Subturno'].value_counts().get('M8.1', 0)
            m82 = CP['Subturno'].value_counts().get('M8.2', 0)
            m83 = CP['Subturno'].value_counts().get('M8.3', 0)
            m84 = CP['Subturno'].value_counts().get('M8.4', 0)
            m85 = CP['Subturno'].value_counts().get('M8.5', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m81,m82,m83,m84,m85])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
            planning.iloc[i,6] = maximo.loc['Subturno']
            planning.iloc[i,7] = maximo.loc['Hora']     

            posicion = maximo.loc['Hora']
            posicion = orden[orden['Hora'] == posicion]
            posicion = posicion.iloc[0,1]
            agentes[posicion] = agentes[posicion] - 1

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad

        if planning.iloc[i,2] == 'M9' and (planning.iloc[i,0] == 'CP' or planning.iloc[i,0] == ' CP' or planning.iloc[i,0] == '  CP' or planning.iloc[i,0] == 'CP ' or planning.iloc[i,0] == 'CP  '):
            cantidad = CP[dia].value_counts().get('M9',0)
            horas_dispo = pausas.loc[[33],['M9.1','M9.2','M9.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M9.1','M9.2','M9.3'])

            m91 = CP['Subturno'].value_counts().get('M9.1', 0)
            m92 = CP['Subturno'].value_counts().get('M9.2', 0)
            m93 = CP['Subturno'].value_counts().get('M9.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m91,m92,m93])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
            planning.iloc[i,6] = maximo.loc['Subturno']
            planning.iloc[i,7] = maximo.loc['Hora']     

            posicion = maximo.loc['Hora']
            posicion = orden[orden['Hora'] == posicion]
            posicion = posicion.iloc[0,1]
            agentes[posicion] = agentes[posicion] - 1

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad
        
        if planning.iloc[i,2] == 'M10' and (planning.iloc[i,0] == 'CP' or planning.iloc[i,0] == ' CP' or planning.iloc[i,0] == '  CP' or planning.iloc[i,0] == 'CP ' or planning.iloc[i,0] == 'CP  '):
            cantidad = CP[dia].value_counts().get('M10',0)
            horas_dispo = pausas.loc[[33],['M10.1','M10.2','M10.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M10.1','M10.2','M10.3'])

            m101 = CP['Subturno'].value_counts().get('M10.1', 0)
            m102 = CP['Subturno'].value_counts().get('M10.2', 0)
            m103 = CP['Subturno'].value_counts().get('M10.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m101,m102,m103])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
            planning.iloc[i,6] = maximo.loc['Subturno']
            planning.iloc[i,7] = maximo.loc['Hora']     

            posicion = maximo.loc['Hora']
            posicion = orden[orden['Hora'] == posicion]
            posicion = posicion.iloc[0,1]
            agentes[posicion] = agentes[posicion] - 1

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad

        if planning.iloc[i,2] == 'M12' and (planning.iloc[i,0] == 'CP' or planning.iloc[i,0] == ' CP' or planning.iloc[i,0] == '  CP' or planning.iloc[i,0] == 'CP ' or planning.iloc[i,0] == 'CP  '):
            cantidad = CP[dia].value_counts().get('M12',0)
            horas_dispo = pausas.loc[[33],['M12.1','M12.2','M12.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M12.1','M12.2','M12.3'])

            m121 = CP['Subturno'].value_counts().get('M12.1', 0)
            m122 = CP['Subturno'].value_counts().get('M12.2', 0)
            m123 = CP['Subturno'].value_counts().get('M12.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m121,m122,m123])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
            planning.iloc[i,6] = maximo.loc['Subturno']
            planning.iloc[i,7] = maximo.loc['Hora']     

            posicion = maximo.loc['Hora']
            posicion = orden[orden['Hora'] == posicion]
            posicion = posicion.iloc[0,1]
            agentes[posicion] = agentes[posicion] - 1

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad

        if planning.iloc[i,2] == 'T13' and (planning.iloc[i,0] == 'CP' or planning.iloc[i,0] == ' CP' or planning.iloc[i,0] == '  CP' or planning.iloc[i,0] == 'CP ' or planning.iloc[i,0] == 'CP  '):
            cantidad = CP[dia].value_counts().get('T13',0)
            horas_dispo = pausas.loc[[33],['T13.1','T13.2','T13.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['T13.1','T13.2','T13.3'])

            t131 = CP['Subturno'].value_counts().get('T13.1', 0)
            t132 = CP['Subturno'].value_counts().get('T13.2', 0)
            t133 = CP['Subturno'].value_counts().get('T13.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [t131,t132,t133])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
            planning.iloc[i,6] = maximo.loc['Subturno']
            planning.iloc[i,7] = maximo.loc['Hora']     

            posicion = maximo.loc['Hora']
            posicion = orden[orden['Hora'] == posicion]
            posicion = posicion.iloc[0,1]
            agentes[posicion] = agentes[posicion] - 1

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad

        if planning.iloc[i,2] == 'M9:30' and (planning.iloc[i,0] == 'CP' or planning.iloc[i,0] == ' CP' or planning.iloc[i,0] == '  CP' or planning.iloc[i,0] == 'CP ' or planning.iloc[i,0] == 'CP  '):
            cantidad = CP[dia].value_counts().get('M9:30',0)
            horas_dispo = pausas.loc[[33],['M9:30.1','M9:30.2','M9:30.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M9:30.1','M9:30.2','M9:30.3'])

            m9301 = CP['Subturno'].value_counts().get('M9:30.1', 0)
            m9302 = CP['Subturno'].value_counts().get('M9:30.2', 0)
            m9303 = CP['Subturno'].value_counts().get('M9:30.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m9301,m9302,m9303])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
            planning.iloc[i,6] = maximo.loc['Subturno']
            planning.iloc[i,7] = maximo.loc['Hora']     

            posicion = maximo.loc['Hora']
            posicion = orden[orden['Hora'] == posicion]
            posicion = posicion.iloc[0,1]
            agentes[posicion] = agentes[posicion] - 1

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad

        if planning.iloc[i,2] == 'T14' and planning.iloc[i,5] == "10'-30'-10'" and (planning.iloc[i,0] == 'CP' or planning.iloc[i,0] == ' CP' or planning.iloc[i,0] == '  CP' or planning.iloc[i,0] == 'CP ' or planning.iloc[i,0] == 'CP  '):
            cantidad = CP[dia].value_counts().get('T14',0)
            horas_dispo = pausas.loc[[33],['T14.1','T14.2','T14.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['T14.1','T14.2','T14.3'])

            t141 = CP['Subturno'].value_counts().get('T14.1', 0)
            t142 = CP['Subturno'].value_counts().get('T14.2', 0)
            t143 = CP['Subturno'].value_counts().get('T14.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [t141,t142,t143])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
            planning.iloc[i,6] = maximo.loc['Subturno']
            planning.iloc[i,7] = maximo.loc['Hora']     

            posicion = maximo.loc['Hora']
            posicion = orden[orden['Hora'] == posicion]
            posicion = posicion.iloc[0,1]
            agentes[posicion] = agentes[posicion] - 1

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad


    #RP, RP/cias, RP/promos
    for i in range(len(planning['Nombre'])):
        RP = planning[planning['Línea'].isin(['RP',' RP','  RP','RP ','RP  ','RP/cias','RP/promos'])]
        if planning.iloc[i,2] == 'M7' and planning.iloc[i,5] == "10'-30'-10'" and (planning.iloc[i,0] == 'RP' or planning.iloc[i,0] == ' RP' or planning.iloc[i,0] == '  RP' or planning.iloc[i,0] == 'RP ' or planning.iloc[i,0] == 'RP  ' or planning.iloc[i,0] == 'RP/cias' or planning.iloc[i,0] == 'RP/promos'):
            cantidad = RP[dia].value_counts().get('M7',0)
            horas_dispo = pausas.loc[[33],['M7.1','M7.2','M7.3','M7.4','M7.5']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M7.1','M7.2','M7.3','M7.4','M7.5'])

            m71 = RP['Subturno'].value_counts().get('M7.1', 0)
            m72 = RP['Subturno'].value_counts().get('M7.2', 0)
            m73 = RP['Subturno'].value_counts().get('M7.3', 0)
            m74 = RP['Subturno'].value_counts().get('M7.4', 0)        
            m75 = RP['Subturno'].value_counts().get('M7.5', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m71,m72,m73,m74,m75])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
            planning.iloc[i,6] = maximo.loc['Subturno']
            planning.iloc[i,7] = maximo.loc['Hora']     

            posicion = maximo.loc['Hora']
            posicion = orden[orden['Hora'] == posicion]
            posicion = posicion.iloc[0,1]
            agentes[posicion] = agentes[posicion] - 1

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad

        if planning.iloc[i,2] == 'M8' and (planning.iloc[i,0] == 'RP' or planning.iloc[i,0] == ' RP' or planning.iloc[i,0] == '  RP' or planning.iloc[i,0] == 'RP ' or planning.iloc[i,0] == 'RP  ' or planning.iloc[i,0] == 'RP/cias' or planning.iloc[i,0] == 'RP/promos'):
            cantidad = RP[dia].value_counts().get('M8',0)
            horas_dispo = pausas.loc[[33],['M8.1','M8.2','M8.3','M8.4','M8.5']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M8.1','M8.2','M8.3','M8.4','M8.5'])

            m81 = RP['Subturno'].value_counts().get('M8.1', 0)
            m82 = RP['Subturno'].value_counts().get('M8.2', 0)
            m83 = RP['Subturno'].value_counts().get('M8.3', 0)
            m84 = RP['Subturno'].value_counts().get('M8.4', 0)
            m85 = RP['Subturno'].value_counts().get('M8.5', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m81,m82,m83,m84,m85])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
            planning.iloc[i,6] = maximo.loc['Subturno']
            planning.iloc[i,7] = maximo.loc['Hora']     

            posicion = maximo.loc['Hora']
            posicion = orden[orden['Hora'] == posicion]
            posicion = posicion.iloc[0,1]
            agentes[posicion] = agentes[posicion] - 1

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad

        if planning.iloc[i,2] == 'M9' and (planning.iloc[i,0] == 'RP' or planning.iloc[i,0] == ' RP' or planning.iloc[i,0] == '  RP' or planning.iloc[i,0] == 'RP ' or planning.iloc[i,0] == 'RP  ' or planning.iloc[i,0] == 'RP/cias' or planning.iloc[i,0] == 'RP/promos'):
            cantidad = RP[dia].value_counts().get('M9',0)
            horas_dispo = pausas.loc[[33],['M9.1','M9.2','M9.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M9.1','M9.2','M9.3'])

            m91 = RP['Subturno'].value_counts().get('M9.1', 0)
            m92 = RP['Subturno'].value_counts().get('M9.2', 0)
            m93 = RP['Subturno'].value_counts().get('M9.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m91,m92,m93])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
            planning.iloc[i,6] = maximo.loc['Subturno']
            planning.iloc[i,7] = maximo.loc['Hora']     

            posicion = maximo.loc['Hora']
            posicion = orden[orden['Hora'] == posicion]
            posicion = posicion.iloc[0,1]
            agentes[posicion] = agentes[posicion] - 1

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad
        
        if planning.iloc[i,2] == 'M10' and (planning.iloc[i,0] == 'RP' or planning.iloc[i,0] == ' RP' or planning.iloc[i,0] == '  RP' or planning.iloc[i,0] == 'RP ' or planning.iloc[i,0] == 'RP  ' or planning.iloc[i,0] == 'RP/cias' or planning.iloc[i,0] == 'RP/promos'):
            cantidad = RP[dia].value_counts().get('M10',0)
            horas_dispo = pausas.loc[[33],['M10.1','M10.2','M10.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M10.1','M10.2','M10.3'])

            m101 = RP['Subturno'].value_counts().get('M10.1', 0)
            m102 = RP['Subturno'].value_counts().get('M10.2', 0)
            m103 = RP['Subturno'].value_counts().get('M10.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m101,m102,m103])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
            planning.iloc[i,6] = maximo.loc['Subturno']
            planning.iloc[i,7] = maximo.loc['Hora']     

            posicion = maximo.loc['Hora']
            posicion = orden[orden['Hora'] == posicion]
            posicion = posicion.iloc[0,1]
            agentes[posicion] = agentes[posicion] - 1

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad

        if planning.iloc[i,2] == 'M12' and (planning.iloc[i,0] == 'RP' or planning.iloc[i,0] == ' RP' or planning.iloc[i,0] == '  RP' or planning.iloc[i,0] == 'RP ' or planning.iloc[i,0] == 'RP  ' or planning.iloc[i,0] == 'RP/cias' or planning.iloc[i,0] == 'RP/promos'):
            cantidad = RP[dia].value_counts().get('M12',0)
            horas_dispo = pausas.loc[[33],['M12.1','M12.2','M12.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M12.1','M12.2','M12.3'])

            m121 = RP['Subturno'].value_counts().get('M12.1', 0)
            m122 = RP['Subturno'].value_counts().get('M12.2', 0)
            m123 = RP['Subturno'].value_counts().get('M12.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m121,m122,m123])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
            planning.iloc[i,6] = maximo.loc['Subturno']
            planning.iloc[i,7] = maximo.loc['Hora']     

            posicion = maximo.loc['Hora']
            posicion = orden[orden['Hora'] == posicion]
            posicion = posicion.iloc[0,1]
            agentes[posicion] = agentes[posicion] - 1

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad

        if planning.iloc[i,2] == 'T13' and (planning.iloc[i,0] == 'RP' or planning.iloc[i,0] == ' RP' or planning.iloc[i,0] == '  RP' or planning.iloc[i,0] == 'RP ' or planning.iloc[i,0] == 'RP  ' or planning.iloc[i,0] == 'RP/cias' or planning.iloc[i,0] == 'RP/promos'):
            cantidad = RP[dia].value_counts().get('T13',0)
            horas_dispo = pausas.loc[[33],['T13.1','T13.2','T13.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['T13.1','T13.2','T13.3'])

            t131 = RP['Subturno'].value_counts().get('T13.1', 0)
            t132 = RP['Subturno'].value_counts().get('T13.2', 0)
            t133 = RP['Subturno'].value_counts().get('T13.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [t131,t132,t133])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
            planning.iloc[i,6] = maximo.loc['Subturno']
            planning.iloc[i,7] = maximo.loc['Hora']     

            posicion = maximo.loc['Hora']
            posicion = orden[orden['Hora'] == posicion]
            posicion = posicion.iloc[0,1]
            agentes[posicion] = agentes[posicion] - 1

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad

        if planning.iloc[i,2] == 'M9:30' and (planning.iloc[i,0] == 'RP' or planning.iloc[i,0] == ' RP' or planning.iloc[i,0] == '  RP' or planning.iloc[i,0] == 'RP ' or planning.iloc[i,0] == 'RP  ' or planning.iloc[i,0] == 'RP/cias' or planning.iloc[i,0] == 'RP/promos'):
            cantidad = RP[dia].value_counts().get('M9:30',0)
            horas_dispo = pausas.loc[[33],['M9:30.1','M9:30.2','M9:30.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M9:30.1','M9:30.2','M9:30.3'])

            m9301 = RP['Subturno'].value_counts().get('M9:30.1', 0)
            m9302 = RP['Subturno'].value_counts().get('M9:30.2', 0)
            m9303 = RP['Subturno'].value_counts().get('M9:30.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m9301,m9302,m9303])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
            planning.iloc[i,6] = maximo.loc['Subturno']
            planning.iloc[i,7] = maximo.loc['Hora']     

            posicion = maximo.loc['Hora']
            posicion = orden[orden['Hora'] == posicion]
            posicion = posicion.iloc[0,1]
            agentes[posicion] = agentes[posicion] - 1

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad

        if planning.iloc[i,2] == 'T14' and planning.iloc[i,5] == "10'-30'-10'" and (planning.iloc[i,0] == 'RP' or planning.iloc[i,0] == ' RP' or planning.iloc[i,0] == '  RP' or planning.iloc[i,0] == 'RP ' or planning.iloc[i,0] == 'RP  ' or planning.iloc[i,0] == 'RP/cias' or planning.iloc[i,0] == 'RP/promos'):
            cantidad = RP[dia].value_counts().get('T14',0)
            horas_dispo = pausas.loc[[33],['T14.1','T14.2','T14.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['T14.1','T14.2','T14.3'])

            t141 = RP['Subturno'].value_counts().get('T14.1', 0)
            t142 = RP['Subturno'].value_counts().get('T14.2', 0)
            t143 = RP['Subturno'].value_counts().get('T14.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [t141,t142,t143])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
            planning.iloc[i,6] = maximo.loc['Subturno']
            planning.iloc[i,7] = maximo.loc['Hora']     

            posicion = maximo.loc['Hora']
            posicion = orden[orden['Hora'] == posicion]
            posicion = posicion.iloc[0,1]
            agentes[posicion] = agentes[posicion] - 1

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad


    #SP
    for i in range(len(planning['Nombre'])):
        SP = planning[planning['Línea'].isin(['SP',' SP','  SP','SP ','SP  '])]
        if planning.iloc[i,2] == 'M7' and planning.iloc[i,5] == "10'-30'-10'" and (planning.iloc[i,0] == 'SP' or planning.iloc[i,0] == ' SP' or planning.iloc[i,0] == '  SP' or planning.iloc[i,0] == 'SP ' or planning.iloc[i,0] == 'SP  '):
            cantidad = SP[dia].value_counts().get('M7',0)
            horas_dispo = pausas.loc[[33],['M7.1','M7.2','M7.3','M7.4','M7.5']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M7.1','M7.2','M7.3','M7.4','M7.5'])

            m71 = SP['Subturno'].value_counts().get('M7.1', 0)
            m72 = SP['Subturno'].value_counts().get('M7.2', 0)
            m73 = SP['Subturno'].value_counts().get('M7.3', 0)
            m74 = SP['Subturno'].value_counts().get('M7.4', 0)        
            m75 = SP['Subturno'].value_counts().get('M7.5', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m71,m72,m73,m74,m75])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
            planning.iloc[i,6] = maximo.loc['Subturno']
            planning.iloc[i,7] = maximo.loc['Hora']     

            posicion = maximo.loc['Hora']
            posicion = orden[orden['Hora'] == posicion]
            posicion = posicion.iloc[0,1]
            agentes[posicion] = agentes[posicion] - 1

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad

        if planning.iloc[i,2] == 'M8' and (planning.iloc[i,0] == 'SP' or planning.iloc[i,0] == ' SP' or planning.iloc[i,0] == '  SP' or planning.iloc[i,0] == 'SP ' or planning.iloc[i,0] == 'SP  '):
            cantidad = SP[dia].value_counts().get('M8',0)
            horas_dispo = pausas.loc[[33],['M8.1','M8.2','M8.3','M8.4','M8.5']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M8.1','M8.2','M8.3','M8.4','M8.5'])

            m81 = SP['Subturno'].value_counts().get('M8.1', 0)
            m82 = SP['Subturno'].value_counts().get('M8.2', 0)
            m83 = SP['Subturno'].value_counts().get('M8.3', 0)
            m84 = SP['Subturno'].value_counts().get('M8.4', 0)
            m85 = SP['Subturno'].value_counts().get('M8.5', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m81,m82,m83,m84,m85])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
            planning.iloc[i,6] = maximo.loc['Subturno']
            planning.iloc[i,7] = maximo.loc['Hora']     

            posicion = maximo.loc['Hora']
            posicion = orden[orden['Hora'] == posicion]
            posicion = posicion.iloc[0,1]
            agentes[posicion] = agentes[posicion] - 1

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad

        if planning.iloc[i,2] == 'M9' and (planning.iloc[i,0] == 'SP' or planning.iloc[i,0] == ' SP' or planning.iloc[i,0] == '  SP' or planning.iloc[i,0] == 'SP ' or planning.iloc[i,0] == 'SP  '):
            cantidad = SP[dia].value_counts().get('M9',0)
            horas_dispo = pausas.loc[[33],['M9.1','M9.2','M9.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M9.1','M9.2','M9.3'])

            m91 = SP['Subturno'].value_counts().get('M9.1', 0)
            m92 = SP['Subturno'].value_counts().get('M9.2', 0)
            m93 = SP['Subturno'].value_counts().get('M9.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m91,m92,m93])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
            planning.iloc[i,6] = maximo.loc['Subturno']
            planning.iloc[i,7] = maximo.loc['Hora']     

            posicion = maximo.loc['Hora']
            posicion = orden[orden['Hora'] == posicion]
            posicion = posicion.iloc[0,1]
            agentes[posicion] = agentes[posicion] - 1

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad
        
        if planning.iloc[i,2] == 'M10' and (planning.iloc[i,0] == 'SP' or planning.iloc[i,0] == ' SP' or planning.iloc[i,0] == '  SP' or planning.iloc[i,0] == 'SP ' or planning.iloc[i,0] == 'SP  '):
            cantidad = SP[dia].value_counts().get('M10',0)
            horas_dispo = pausas.loc[[33],['M10.1','M10.2','M10.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M10.1','M10.2','M10.3'])

            m101 = SP['Subturno'].value_counts().get('M10.1', 0)
            m102 = SP['Subturno'].value_counts().get('M10.2', 0)
            m103 = SP['Subturno'].value_counts().get('M10.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m101,m102,m103])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
            planning.iloc[i,6] = maximo.loc['Subturno']
            planning.iloc[i,7] = maximo.loc['Hora']     

            posicion = maximo.loc['Hora']
            posicion = orden[orden['Hora'] == posicion]
            posicion = posicion.iloc[0,1]
            agentes[posicion] = agentes[posicion] - 1

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad

        if planning.iloc[i,2] == 'M12' and (planning.iloc[i,0] == 'SP' or planning.iloc[i,0] == ' SP' or planning.iloc[i,0] == '  SP' or planning.iloc[i,0] == 'SP ' or planning.iloc[i,0] == 'SP  '):
            cantidad = SP[dia].value_counts().get('M12',0)
            horas_dispo = pausas.loc[[33],['M12.1','M12.2','M12.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M12.1','M12.2','M12.3'])

            m121 = SP['Subturno'].value_counts().get('M12.1', 0)
            m122 = SP['Subturno'].value_counts().get('M12.2', 0)
            m123 = SP['Subturno'].value_counts().get('M12.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m121,m122,m123])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
            planning.iloc[i,6] = maximo.loc['Subturno']
            planning.iloc[i,7] = maximo.loc['Hora']     

            posicion = maximo.loc['Hora']
            posicion = orden[orden['Hora'] == posicion]
            posicion = posicion.iloc[0,1]
            agentes[posicion] = agentes[posicion] - 1

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad

        if planning.iloc[i,2] == 'T13' and (planning.iloc[i,0] == 'SP' or planning.iloc[i,0] == ' SP' or planning.iloc[i,0] == '  SP' or planning.iloc[i,0] == 'SP ' or planning.iloc[i,0] == 'SP  '):
            cantidad = SP[dia].value_counts().get('T13',0)
            horas_dispo = pausas.loc[[33],['T13.1','T13.2','T13.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['T13.1','T13.2','T13.3'])

            t131 = SP['Subturno'].value_counts().get('T13.1', 0)
            t132 = SP['Subturno'].value_counts().get('T13.2', 0)
            t133 = SP['Subturno'].value_counts().get('T13.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [t131,t132,t133])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
            planning.iloc[i,6] = maximo.loc['Subturno']
            planning.iloc[i,7] = maximo.loc['Hora']     

            posicion = maximo.loc['Hora']
            posicion = orden[orden['Hora'] == posicion]
            posicion = posicion.iloc[0,1]
            agentes[posicion] = agentes[posicion] - 1

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad

        if planning.iloc[i,2] == 'M9:30' and (planning.iloc[i,0] == 'SP' or planning.iloc[i,0] == ' SP' or planning.iloc[i,0] == '  SP' or planning.iloc[i,0] == 'SP ' or planning.iloc[i,0] == 'SP  '):
            cantidad = SP[dia].value_counts().get('M9:30',0)
            horas_dispo = pausas.loc[[33],['M9:30.1','M9:30.2','M9:30.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M9:30.1','M9:30.2','M9:30.3'])

            m9301 = SP['Subturno'].value_counts().get('M9:30.1', 0)
            m9302 = SP['Subturno'].value_counts().get('M9:30.2', 0)
            m9303 = SP['Subturno'].value_counts().get('M9:30.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m9301,m9302,m9303])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
            planning.iloc[i,6] = maximo.loc['Subturno']
            planning.iloc[i,7] = maximo.loc['Hora']     

            posicion = maximo.loc['Hora']
            posicion = orden[orden['Hora'] == posicion]
            posicion = posicion.iloc[0,1]
            agentes[posicion] = agentes[posicion] - 1

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100) 
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad

        if planning.iloc[i,2] == 'T14' and planning.iloc[i,5] == "10'-30'-10'" and (planning.iloc[i,0] == 'SP' or planning.iloc[i,0] == ' SP' or planning.iloc[i,0] == '  SP' or planning.iloc[i,0] == 'SP ' or planning.iloc[i,0] == 'SP  '):
            cantidad = SP[dia].value_counts().get('T14',0)
            horas_dispo = pausas.loc[[33],['T14.1','T14.2','T14.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['T14.1','T14.2','T14.3'])

            t141 = SP['Subturno'].value_counts().get('T14.1', 0)
            t142 = SP['Subturno'].value_counts().get('T14.2', 0)
            t143 = SP['Subturno'].value_counts().get('T14.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [t141,t142,t143])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
            planning.iloc[i,6] = maximo.loc['Subturno']
            planning.iloc[i,7] = maximo.loc['Hora']     

            posicion = maximo.loc['Hora']
            posicion = orden[orden['Hora'] == posicion]
            posicion = posicion.iloc[0,1]
            agentes[posicion] = agentes[posicion] - 1

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad


    #RP/AT-RP, RP/AT-RP-SP, RP/AT-RP-SP/promos, RP/AT-RP/promos
    for i in range(len(planning['Nombre'])):
        RPAT = planning[planning['Línea'].isin(['RP/AT-RP',' RP/AT-RP','  RP/AT-RP','RP/AT-RP ','RP/AT-RP  ','RP/AT-RP-SP','RP/AT-RP-SP/promos','RP/AT-RP/promos'])]
        if planning.iloc[i,2] == 'M7' and planning.iloc[i,5] == "10'-30'-10'" and (planning.iloc[i,0] == 'RP/AT-RP' or planning.iloc[i,0] == ' RP/AT-RP' or planning.iloc[i,0] == '  RP/AT-RP' or planning.iloc[i,0] == 'RP/AT-RP ' or planning.iloc[i,0] == 'RP/AT-RP  ' or planning.iloc[i,0] == 'RP/AT-RP-SP' or planning.iloc[i,0] == 'RP/AT-RP-SP/promos' or planning.iloc[i,0] == 'RP/AT-RP/promos'):
            cantidad = RPAT[dia].value_counts().get('M7',0)
            horas_dispo = pausas.loc[[33],['M7.1','M7.2','M7.3','M7.4','M7.5']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M7.1','M7.2','M7.3','M7.4','M7.5'])

            m71 = RPAT['Subturno'].value_counts().get('M7.1', 0)
            m72 = RPAT['Subturno'].value_counts().get('M7.2', 0)
            m73 = RPAT['Subturno'].value_counts().get('M7.3', 0)
            m74 = RPAT['Subturno'].value_counts().get('M7.4', 0)        
            m75 = RPAT['Subturno'].value_counts().get('M7.5', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m71,m72,m73,m74,m75])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
            planning.iloc[i,6] = maximo.loc['Subturno']
            planning.iloc[i,7] = maximo.loc['Hora']     

            posicion = maximo.loc['Hora']
            posicion = orden[orden['Hora'] == posicion]
            posicion = posicion.iloc[0,1]
            agentes[posicion] = agentes[posicion] - 1

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad

        if planning.iloc[i,2] == 'M8' and (planning.iloc[i,0] == 'RP/AT-RP' or planning.iloc[i,0] == ' RP/AT-RP' or planning.iloc[i,0] == '  RP/AT-RP' or planning.iloc[i,0] == 'RP/AT-RP ' or planning.iloc[i,0] == 'RP/AT-RP  ' or planning.iloc[i,0] == 'RP/AT-RP-SP' or planning.iloc[i,0] == 'RP/AT-RP-SP/promos' or planning.iloc[i,0] == 'RP/AT-RP/promos'):
            cantidad = RPAT[dia].value_counts().get('M8',0)
            horas_dispo = pausas.loc[[33],['M8.1','M8.2','M8.3','M8.4','M8.5']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M8.1','M8.2','M8.3','M8.4','M8.5'])

            m81 = RPAT['Subturno'].value_counts().get('M8.1', 0)
            m82 = RPAT['Subturno'].value_counts().get('M8.2', 0)
            m83 = RPAT['Subturno'].value_counts().get('M8.3', 0)
            m84 = RPAT['Subturno'].value_counts().get('M8.4', 0)
            m85 = RPAT['Subturno'].value_counts().get('M8.5', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m81,m82,m83,m84,m85])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
            planning.iloc[i,6] = maximo.loc['Subturno']
            planning.iloc[i,7] = maximo.loc['Hora']     

            posicion = maximo.loc['Hora']
            posicion = orden[orden['Hora'] == posicion]
            posicion = posicion.iloc[0,1]
            agentes[posicion] = agentes[posicion] - 1

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad

        if planning.iloc[i,2] == 'M9' and (planning.iloc[i,0] == 'RP/AT-RP' or planning.iloc[i,0] == ' RP/AT-RP' or planning.iloc[i,0] == '  RP/AT-RP' or planning.iloc[i,0] == 'RP/AT-RP ' or planning.iloc[i,0] == 'RP/AT-RP  ' or planning.iloc[i,0] == 'RP/AT-RP-SP' or planning.iloc[i,0] == 'RP/AT-RP-SP/promos' or planning.iloc[i,0] == 'RP/AT-RP/promos'):
            cantidad = RPAT[dia].value_counts().get('M9',0)
            horas_dispo = pausas.loc[[33],['M9.1','M9.2','M9.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M9.1','M9.2','M9.3'])

            m91 = RPAT['Subturno'].value_counts().get('M9.1', 0)
            m92 = RPAT['Subturno'].value_counts().get('M9.2', 0)
            m93 = RPAT['Subturno'].value_counts().get('M9.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m91,m92,m93])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
            planning.iloc[i,6] = maximo.loc['Subturno']
            planning.iloc[i,7] = maximo.loc['Hora']     

            posicion = maximo.loc['Hora']
            posicion = orden[orden['Hora'] == posicion]
            posicion = posicion.iloc[0,1]
            agentes[posicion] = agentes[posicion] - 1

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad
        
        if planning.iloc[i,2] == 'M10' and (planning.iloc[i,0] == 'RP/AT-RP' or planning.iloc[i,0] == ' RP/AT-RP' or planning.iloc[i,0] == '  RP/AT-RP' or planning.iloc[i,0] == 'RP/AT-RP ' or planning.iloc[i,0] == 'RP/AT-RP  ' or planning.iloc[i,0] == 'RP/AT-RP-SP' or planning.iloc[i,0] == 'RP/AT-RP-SP/promos' or planning.iloc[i,0] == 'RP/AT-RP/promos'):
            cantidad = RPAT[dia].value_counts().get('M10',0)
            horas_dispo = pausas.loc[[33],['M10.1','M10.2','M10.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M10.1','M10.2','M10.3'])

            m101 = RPAT['Subturno'].value_counts().get('M10.1', 0)
            m102 = RPAT['Subturno'].value_counts().get('M10.2', 0)
            m103 = RPAT['Subturno'].value_counts().get('M10.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m101,m102,m103])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
            planning.iloc[i,6] = maximo.loc['Subturno']
            planning.iloc[i,7] = maximo.loc['Hora']     

            posicion = maximo.loc['Hora']
            posicion = orden[orden['Hora'] == posicion]
            posicion = posicion.iloc[0,1]
            agentes[posicion] = agentes[posicion] - 1

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad

        if planning.iloc[i,2] == 'M12' and (planning.iloc[i,0] == 'RP/AT-RP' or planning.iloc[i,0] == ' RP/AT-RP' or planning.iloc[i,0] == '  RP/AT-RP' or planning.iloc[i,0] == 'RP/AT-RP ' or planning.iloc[i,0] == 'RP/AT-RP  ' or planning.iloc[i,0] == 'RP/AT-RP-SP' or planning.iloc[i,0] == 'RP/AT-RP-SP/promos' or planning.iloc[i,0] == 'RP/AT-RP/promos'):
            cantidad = RPAT[dia].value_counts().get('M12',0)
            horas_dispo = pausas.loc[[33],['M12.1','M12.2','M12.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M12.1','M12.2','M12.3'])

            m121 = RPAT['Subturno'].value_counts().get('M12.1', 0)
            m122 = RPAT['Subturno'].value_counts().get('M12.2', 0)
            m123 = RPAT['Subturno'].value_counts().get('M12.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m121,m122,m123])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
            planning.iloc[i,6] = maximo.loc['Subturno']
            planning.iloc[i,7] = maximo.loc['Hora']     

            posicion = maximo.loc['Hora']
            posicion = orden[orden['Hora'] == posicion]
            posicion = posicion.iloc[0,1]
            agentes[posicion] = agentes[posicion] - 1

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad

        if planning.iloc[i,2] == 'T13' and (planning.iloc[i,0] == 'RP/AT-RP' or planning.iloc[i,0] == ' RP/AT-RP' or planning.iloc[i,0] == '  RP/AT-RP' or planning.iloc[i,0] == 'RP/AT-RP ' or planning.iloc[i,0] == 'RP/AT-RP  ' or planning.iloc[i,0] == 'RP/AT-RP-SP' or planning.iloc[i,0] == 'RP/AT-RP-SP/promos' or planning.iloc[i,0] == 'RP/AT-RP/promos'):
            cantidad = RPAT[dia].value_counts().get('T13',0)
            horas_dispo = pausas.loc[[33],['T13.1','T13.2','T13.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['T13.1','T13.2','T13.3'])

            t131 = RPAT['Subturno'].value_counts().get('T13.1', 0)
            t132 = RPAT['Subturno'].value_counts().get('T13.2', 0)
            t133 = RPAT['Subturno'].value_counts().get('T13.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [t131,t132,t133])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
            planning.iloc[i,6] = maximo.loc['Subturno']
            planning.iloc[i,7] = maximo.loc['Hora']     

            posicion = maximo.loc['Hora']
            posicion = orden[orden['Hora'] == posicion]
            posicion = posicion.iloc[0,1]
            agentes[posicion] = agentes[posicion] - 1

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad

        if planning.iloc[i,2] == 'M9:30' and (planning.iloc[i,0] == 'RP/AT-RP' or planning.iloc[i,0] == ' RP/AT-RP' or planning.iloc[i,0] == '  RP/AT-RP' or planning.iloc[i,0] == 'RP/AT-RP ' or planning.iloc[i,0] == 'RP/AT-RP  ' or planning.iloc[i,0] == 'RP/AT-RP-SP' or planning.iloc[i,0] == 'RP/AT-RP-SP/promos' or planning.iloc[i,0] == 'RP/AT-RP/promos'):
            cantidad = RPAT[dia].value_counts().get('M9:30',0)
            horas_dispo = pausas.loc[[33],['M9:30.1','M9:30.2','M9:30.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M9:30.1','M9:30.2','M9:30.3'])

            m9301 = RPAT['Subturno'].value_counts().get('M9:30.1', 0)
            m9302 = RPAT['Subturno'].value_counts().get('M9:30.2', 0)
            m9303 = RPAT['Subturno'].value_counts().get('M9:30.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m9301,m9302,m9303])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
            planning.iloc[i,6] = maximo.loc['Subturno']
            planning.iloc[i,7] = maximo.loc['Hora']     

            posicion = maximo.loc['Hora']
            posicion = orden[orden['Hora'] == posicion]
            posicion = posicion.iloc[0,1]
            agentes[posicion] = agentes[posicion] - 1

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad

        if planning.iloc[i,2] == 'T14' and planning.iloc[i,5] == "10'-30'-10'" and (planning.iloc[i,0] == 'RP/AT-RP' or planning.iloc[i,0] == ' RP/AT-RP' or planning.iloc[i,0] == '  RP/AT-RP' or planning.iloc[i,0] == 'RP/AT-RP ' or planning.iloc[i,0] == 'RP/AT-RP  ' or planning.iloc[i,0] == 'RP/AT-RP-SP' or planning.iloc[i,0] == 'RP/AT-RP-SP/promos' or planning.iloc[i,0] == 'RP/AT-RP/promos'):
            cantidad = RPAT[dia].value_counts().get('T14',0)
            horas_dispo = pausas.loc[[33],['T14.1','T14.2','T14.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['T14.1','T14.2','T14.3'])

            t141 = RPAT['Subturno'].value_counts().get('T14.1', 0)
            t142 = RPAT['Subturno'].value_counts().get('T14.2', 0)
            t143 = RPAT['Subturno'].value_counts().get('T14.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [t141,t142,t143])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
            planning.iloc[i,6] = maximo.loc['Subturno']
            planning.iloc[i,7] = maximo.loc['Hora']     

            posicion = maximo.loc['Hora']
            posicion = orden[orden['Hora'] == posicion]
            posicion = posicion.iloc[0,1]
            agentes[posicion] = agentes[posicion] - 1

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad


    #RP/CP, RP/CP/promos
    for i in range(len(planning['Nombre'])):
        RPCP = planning[planning['Línea'].isin(['RP/CP',' RP/CP','  RP/CP','RP/CP ','RP/CP  ','RP/CP/promos'])]
        if planning.iloc[i,2] == 'M7' and planning.iloc[i,5] == "10'-30'-10'" and (planning.iloc[i,0] == 'RP/CP' or planning.iloc[i,0] == ' RP/CP' or planning.iloc[i,0] == '  RP/CP' or planning.iloc[i,0] == 'RP/CP ' or planning.iloc[i,0] == 'RP/CP  ' or planning.iloc[i,0] == 'RP/CP/promos'):
            cantidad = RPCP[dia].value_counts().get('M7',0)
            horas_dispo = pausas.loc[[33],['M7.1','M7.2','M7.3','M7.4','M7.5']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M7.1','M7.2','M7.3','M7.4','M7.5'])

            m71 = RPCP['Subturno'].value_counts().get('M7.1', 0)
            m72 = RPCP['Subturno'].value_counts().get('M7.2', 0)
            m73 = RPCP['Subturno'].value_counts().get('M7.3', 0)
            m74 = RPCP['Subturno'].value_counts().get('M7.4', 0)        
            m75 = RPCP['Subturno'].value_counts().get('M7.5', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m71,m72,m73,m74,m75])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
            planning.iloc[i,6] = maximo.loc['Subturno']
            planning.iloc[i,7] = maximo.loc['Hora']     

            posicion = maximo.loc['Hora']
            posicion = orden[orden['Hora'] == posicion]
            posicion = posicion.iloc[0,1]
            agentes[posicion] = agentes[posicion] - 1

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad

        if planning.iloc[i,2] == 'M8' and (planning.iloc[i,0] == 'RP/CP' or planning.iloc[i,0] == ' RP/CP' or planning.iloc[i,0] == '  RP/CP' or planning.iloc[i,0] == 'RP/CP ' or planning.iloc[i,0] == 'RP/CP  ' or planning.iloc[i,0] == 'RP/CP/promos'):
            cantidad = RPCP[dia].value_counts().get('M8',0)
            horas_dispo = pausas.loc[[33],['M8.1','M8.2','M8.3','M8.4','M8.5']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M8.1','M8.2','M8.3','M8.4','M8.5'])

            m81 = RPCP['Subturno'].value_counts().get('M8.1', 0)
            m82 = RPCP['Subturno'].value_counts().get('M8.2', 0)
            m83 = RPCP['Subturno'].value_counts().get('M8.3', 0)
            m84 = RPCP['Subturno'].value_counts().get('M8.4', 0)
            m85 = RPCP['Subturno'].value_counts().get('M8.5', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m81,m82,m83,m84,m85])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
            planning.iloc[i,6] = maximo.loc['Subturno']
            planning.iloc[i,7] = maximo.loc['Hora']     

            posicion = maximo.loc['Hora']
            posicion = orden[orden['Hora'] == posicion]
            posicion = posicion.iloc[0,1]
            agentes[posicion] = agentes[posicion] - 1

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad

        if planning.iloc[i,2] == 'M9' and (planning.iloc[i,0] == 'RP/CP' or planning.iloc[i,0] == ' RP/CP' or planning.iloc[i,0] == '  RP/CP' or planning.iloc[i,0] == 'RP/CP ' or planning.iloc[i,0] == 'RP/CP  ' or planning.iloc[i,0] == 'RP/CP/promos'):
            cantidad = RPCP[dia].value_counts().get('M9',0)
            horas_dispo = pausas.loc[[33],['M9.1','M9.2','M9.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M9.1','M9.2','M9.3'])

            m91 = RPCP['Subturno'].value_counts().get('M9.1', 0)
            m92 = RPCP['Subturno'].value_counts().get('M9.2', 0)
            m93 = RPCP['Subturno'].value_counts().get('M9.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m91,m92,m93])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
            planning.iloc[i,6] = maximo.loc['Subturno']
            planning.iloc[i,7] = maximo.loc['Hora']     

            posicion = maximo.loc['Hora']
            posicion = orden[orden['Hora'] == posicion]
            posicion = posicion.iloc[0,1]
            agentes[posicion] = agentes[posicion] - 1

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad
        
        if planning.iloc[i,2] == 'M10' and (planning.iloc[i,0] == 'RP/CP' or planning.iloc[i,0] == ' RP/CP' or planning.iloc[i,0] == '  RP/CP' or planning.iloc[i,0] == 'RP/CP ' or planning.iloc[i,0] == 'RP/CP  ' or planning.iloc[i,0] == 'RP/CP/promos'):
            cantidad = RPCP[dia].value_counts().get('M10',0)
            horas_dispo = pausas.loc[[33],['M10.1','M10.2','M10.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M10.1','M10.2','M10.3'])

            m101 = RPCP['Subturno'].value_counts().get('M10.1', 0)
            m102 = RPCP['Subturno'].value_counts().get('M10.2', 0)
            m103 = RPCP['Subturno'].value_counts().get('M10.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m101,m102,m103])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
            planning.iloc[i,6] = maximo.loc['Subturno']
            planning.iloc[i,7] = maximo.loc['Hora']     

            posicion = maximo.loc['Hora']
            posicion = orden[orden['Hora'] == posicion]
            posicion = posicion.iloc[0,1]
            agentes[posicion] = agentes[posicion] - 1

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad

        if planning.iloc[i,2] == 'M12' and (planning.iloc[i,0] == 'RP/CP' or planning.iloc[i,0] == ' RP/CP' or planning.iloc[i,0] == '  RP/CP' or planning.iloc[i,0] == 'RP/CP ' or planning.iloc[i,0] == 'RP/CP  '):
            cantidad = RPCP[dia].value_counts().get('M12',0)
            horas_dispo = pausas.loc[[33],['M12.1','M12.2','M12.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M12.1','M12.2','M12.3'])

            m121 = RPCP['Subturno'].value_counts().get('M12.1', 0)
            m122 = RPCP['Subturno'].value_counts().get('M12.2', 0)
            m123 = RPCP['Subturno'].value_counts().get('M12.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m121,m122,m123])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
            planning.iloc[i,6] = maximo.loc['Subturno']
            planning.iloc[i,7] = maximo.loc['Hora']     

            posicion = maximo.loc['Hora']
            posicion = orden[orden['Hora'] == posicion]
            posicion = posicion.iloc[0,1]
            agentes[posicion] = agentes[posicion] - 1

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad

        if planning.iloc[i,2] == 'T13' and (planning.iloc[i,0] == 'RP/CP' or planning.iloc[i,0] == ' RP/CP' or planning.iloc[i,0] == '  RP/CP' or planning.iloc[i,0] == 'RP/CP ' or planning.iloc[i,0] == 'RP/CP  ' or planning.iloc[i,0] == 'RP/CP/promos'):
            cantidad = RPCP[dia].value_counts().get('T13',0)
            horas_dispo = pausas.loc[[33],['T13.1','T13.2','T13.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['T13.1','T13.2','T13.3'])

            t131 = RPCP['Subturno'].value_counts().get('T13.1', 0)
            t132 = RPCP['Subturno'].value_counts().get('T13.2', 0)
            t133 = RPCP['Subturno'].value_counts().get('T13.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [t131,t132,t133])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
            planning.iloc[i,6] = maximo.loc['Subturno']
            planning.iloc[i,7] = maximo.loc['Hora']     

            posicion = maximo.loc['Hora']
            posicion = orden[orden['Hora'] == posicion]
            posicion = posicion.iloc[0,1]
            agentes[posicion] = agentes[posicion] - 1

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad

        if planning.iloc[i,2] == 'M9:30' and (planning.iloc[i,0] == 'RP/CP' or planning.iloc[i,0] == ' RP/CP' or planning.iloc[i,0] == '  RP/CP' or planning.iloc[i,0] == 'RP/CP ' or planning.iloc[i,0] == 'RP/CP  ' or planning.iloc[i,0] == 'RP/CP/promos'):
            cantidad = RPCP[dia].value_counts().get('M9:30',0)
            horas_dispo = pausas.loc[[33],['M9:30.1','M9:30.2','M9:30.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M9:30.1','M9:30.2','M9:30.3'])

            m9301 = RPCP['Subturno'].value_counts().get('M9:30.1', 0)
            m9302 = RPCP['Subturno'].value_counts().get('M9:30.2', 0)
            m9303 = RPCP['Subturno'].value_counts().get('M9:30.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m9301,m9302,m9303])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
            planning.iloc[i,6] = maximo.loc['Subturno']
            planning.iloc[i,7] = maximo.loc['Hora']     

            posicion = maximo.loc['Hora']
            posicion = orden[orden['Hora'] == posicion]
            posicion = posicion.iloc[0,1]
            agentes[posicion] = agentes[posicion] - 1

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad

        if planning.iloc[i,2] == 'T14' and planning.iloc[i,5] == "10'-30'-10'" and (planning.iloc[i,0] == 'RP/CP' or planning.iloc[i,0] == ' RP/CP' or planning.iloc[i,0] == '  RP/CP' or planning.iloc[i,0] == 'RP/CP ' or planning.iloc[i,0] == 'RP/CP  ' or planning.iloc[i,0] == 'RP/CP/promos'):
            cantidad = RPCP[dia].value_counts().get('T14',0)
            horas_dispo = pausas.loc[[33],['T14.1','T14.2','T14.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['T14.1','T14.2','T14.3'])

            t141 = RPCP['Subturno'].value_counts().get('T14.1', 0)
            t142 = RPCP['Subturno'].value_counts().get('T14.2', 0)
            t143 = RPCP['Subturno'].value_counts().get('T14.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [t141,t142,t143])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
            planning.iloc[i,6] = maximo.loc['Subturno']
            planning.iloc[i,7] = maximo.loc['Hora']     

            posicion = maximo.loc['Hora']
            posicion = orden[orden['Hora'] == posicion]
            posicion = posicion.iloc[0,1]
            agentes[posicion] = agentes[posicion] - 1

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad


    #RP/SP, RP/SP/cias
    for i in range(len(planning['Nombre'])):
        RPSP = planning[planning['Línea'].isin(['RP/SP',' RP/SP','  RP/SP','RP/SP ','RP/SP  ','RP/SP/cias'])]
        if planning.iloc[i,2] == 'M7' and planning.iloc[i,5] == "10'-30'-10'" and (planning.iloc[i,0] == 'RP/SP' or planning.iloc[i,0] == ' RP/SP' or planning.iloc[i,0] == '  RP/SP' or planning.iloc[i,0] == 'RP/SP ' or planning.iloc[i,0] == 'RP/SP  ' or planning.iloc[i,0] == 'RP/SP/cias'):
            cantidad = RPSP[dia].value_counts().get('M7',0)
            horas_dispo = pausas.loc[[33],['M7.1','M7.2','M7.3','M7.4','M7.5']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M7.1','M7.2','M7.3','M7.4','M7.5'])

            m71 = RPSP['Subturno'].value_counts().get('M7.1', 0)
            m72 = RPSP['Subturno'].value_counts().get('M7.2', 0)
            m73 = RPSP['Subturno'].value_counts().get('M7.3', 0)
            m74 = RPSP['Subturno'].value_counts().get('M7.4', 0)        
            m75 = RPSP['Subturno'].value_counts().get('M7.5', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m71,m72,m73,m74,m75])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            if not horas_dispo[horas_dispo['Accesibilidad'] == maximo].empty:
                maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
                planning.iloc[i,6] = maximo.loc['Subturno']
                planning.iloc[i,7] = maximo.loc['Hora']     

                posicion = maximo.loc['Hora']
                posicion = orden[orden['Hora'] == posicion]
                posicion = posicion.iloc[0,1]
                agentes[posicion] = agentes[posicion] - 1

                contestadas = agentes * productividad
                contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
                accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
                accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

                acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
                acc.iloc[:,0] = horas
                acc.iloc[:,1] = accesibilidad

            else:
                print("No rows found with the specified condition.")

        if planning.iloc[i,2] == 'M8' and (planning.iloc[i,0] == 'RP/SP' or planning.iloc[i,0] == ' RP/SP' or planning.iloc[i,0] == '  RP/SP' or planning.iloc[i,0] == 'RP/SP ' or planning.iloc[i,0] == 'RP/SP  ' or planning.iloc[i,0] == 'RP/SP/cias'):
            cantidad = RPSP[dia].value_counts().get('M8',0)
            horas_dispo = pausas.loc[[33],['M8.1','M8.2','M8.3','M8.4','M8.5']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M8.1','M8.2','M8.3','M8.4','M8.5'])

            m81 = RPSP['Subturno'].value_counts().get('M8.1', 0)
            m82 = RPSP['Subturno'].value_counts().get('M8.2', 0)
            m83 = RPSP['Subturno'].value_counts().get('M8.3', 0)
            m84 = RPSP['Subturno'].value_counts().get('M8.4', 0)
            m85 = RPSP['Subturno'].value_counts().get('M8.5', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m81,m82,m83,m84,m85])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            if not horas_dispo[horas_dispo['Accesibilidad'] == maximo].empty:
                maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
                planning.iloc[i,6] = maximo.loc['Subturno']
                planning.iloc[i,7] = maximo.loc['Hora']     

                posicion = maximo.loc['Hora']
                posicion = orden[orden['Hora'] == posicion]
                posicion = posicion.iloc[0,1]
                agentes[posicion] = agentes[posicion] - 1

                contestadas = agentes * productividad
                contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
                accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
                accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

                acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
                acc.iloc[:,0] = horas
                acc.iloc[:,1] = accesibilidad

            else:
                print("No rows found with the specified condition.")

        if planning.iloc[i,2] == 'M9' and (planning.iloc[i,0] == 'RP/SP' or planning.iloc[i,0] == ' RP/SP' or planning.iloc[i,0] == '  RP/SP' or planning.iloc[i,0] == 'RP/SP ' or planning.iloc[i,0] == 'RP/SP  ' or planning.iloc[i,0] == 'RP/SP/cias'):
            cantidad = RPSP[dia].value_counts().get('M9',0)
            horas_dispo = pausas.loc[[33],['M9.1','M9.2','M9.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M9.1','M9.2','M9.3'])

            m91 = RPSP['Subturno'].value_counts().get('M9.1', 0)
            m92 = RPSP['Subturno'].value_counts().get('M9.2', 0)
            m93 = RPSP['Subturno'].value_counts().get('M9.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m91,m92,m93])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            if not horas_dispo[horas_dispo['Accesibilidad'] == maximo].empty:
                maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
                planning.iloc[i,6] = maximo.loc['Subturno']
                planning.iloc[i,7] = maximo.loc['Hora']     

                posicion = maximo.loc['Hora']
                posicion = orden[orden['Hora'] == posicion]
                posicion = posicion.iloc[0,1]
                agentes[posicion] = agentes[posicion] - 1

                contestadas = agentes * productividad
                contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
                accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
                accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

                acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
                acc.iloc[:,0] = horas
                acc.iloc[:,1] = accesibilidad

            else:
                print("No rows found with the specified condition.")
        
        if planning.iloc[i,2] == 'M10' and (planning.iloc[i,0] == 'RP/SP' or planning.iloc[i,0] == ' RP/SP' or planning.iloc[i,0] == '  RP/SP' or planning.iloc[i,0] == 'RP/SP ' or planning.iloc[i,0] == 'RP/SP  ' or planning.iloc[i,0] == 'RP/SP/cias'):
            cantidad = RPSP[dia].value_counts().get('M10',0)
            horas_dispo = pausas.loc[[33],['M10.1','M10.2','M10.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M10.1','M10.2','M10.3'])

            m101 = RPSP['Subturno'].value_counts().get('M10.1', 0)
            m102 = RPSP['Subturno'].value_counts().get('M10.2', 0)
            m103 = RPSP['Subturno'].value_counts().get('M10.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m101,m102,m103])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            if not horas_dispo[horas_dispo['Accesibilidad'] == maximo].empty:
                maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
                planning.iloc[i,6] = maximo.loc['Subturno']
                planning.iloc[i,7] = maximo.loc['Hora']     

                posicion = maximo.loc['Hora']
                posicion = orden[orden['Hora'] == posicion]
                posicion = posicion.iloc[0,1]
                agentes[posicion] = agentes[posicion] - 1

                contestadas = agentes * productividad
                contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
                accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
                accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

                acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
                acc.iloc[:,0] = horas
                acc.iloc[:,1] = accesibilidad

            else:
                print("No rows found with the specified condition.")

        if planning.iloc[i,2] == 'M12' and (planning.iloc[i,0] == 'RP/SP' or planning.iloc[i,0] == ' RP/SP' or planning.iloc[i,0] == '  RP/SP' or planning.iloc[i,0] == 'RP/SP ' or planning.iloc[i,0] == 'RP/SP  ' or planning.iloc[i,0] == 'RP/SP/cias'):
            cantidad = RPSP[dia].value_counts().get('M12',0)
            horas_dispo = pausas.loc[[33],['M12.1','M12.2','M12.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M12.1','M12.2','M12.3'])

            m121 = RPSP['Subturno'].value_counts().get('M12.1', 0)
            m122 = RPSP['Subturno'].value_counts().get('M12.2', 0)
            m123 = RPSP['Subturno'].value_counts().get('M12.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m121,m122,m123])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            if not horas_dispo[horas_dispo['Accesibilidad'] == maximo].empty:
                maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
                planning.iloc[i,6] = maximo.loc['Subturno']
                planning.iloc[i,7] = maximo.loc['Hora']     

                posicion = maximo.loc['Hora']
                posicion = orden[orden['Hora'] == posicion]
                posicion = posicion.iloc[0,1]
                agentes[posicion] = agentes[posicion] - 1

                contestadas = agentes * productividad
                contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
                accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
                accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

                acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
                acc.iloc[:,0] = horas
                acc.iloc[:,1] = accesibilidad

            else:
                print("No rows found with the specified condition.")

        if planning.iloc[i,2] == 'T13' and (planning.iloc[i,0] == 'RP/SP' or planning.iloc[i,0] == ' RP/SP' or planning.iloc[i,0] == '  RP/SP' or planning.iloc[i,0] == 'RP/SP ' or planning.iloc[i,0] == 'RP/SP  ' or planning.iloc[i,0] == 'RP/SP/cias'):
            cantidad = RPSP[dia].value_counts().get('T13',0)
            horas_dispo = pausas.loc[[33],['T13.1','T13.2','T13.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['T13.1','T13.2','T13.3'])

            t131 = RPSP['Subturno'].value_counts().get('T13.1', 0)
            t132 = RPSP['Subturno'].value_counts().get('T13.2', 0)
            t133 = RPSP['Subturno'].value_counts().get('T13.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [t131,t132,t133])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            if not horas_dispo[horas_dispo['Accesibilidad'] == maximo].empty:
                maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
                planning.iloc[i,6] = maximo.loc['Subturno']
                planning.iloc[i,7] = maximo.loc['Hora']     

                posicion = maximo.loc['Hora']
                posicion = orden[orden['Hora'] == posicion]
                posicion = posicion.iloc[0,1]
                agentes[posicion] = agentes[posicion] - 1

                contestadas = agentes * productividad
                contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
                accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
                accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

                acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
                acc.iloc[:,0] = horas
                acc.iloc[:,1] = accesibilidad

            else:
                print("No rows found with the specified condition.")

        if planning.iloc[i,2] == 'M9:30' and (planning.iloc[i,0] == 'RP/SP' or planning.iloc[i,0] == ' RP/SP' or planning.iloc[i,0] == '  RP/SP' or planning.iloc[i,0] == 'RP/SP ' or planning.iloc[i,0] == 'RP/SP  ' or planning.iloc[i,0] == 'RP/SP/cias'):
            cantidad = RPSP[dia].value_counts().get('M9:30',0)
            horas_dispo = pausas.loc[[33],['M9:30.1','M9:30.2','M9:30.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M9:30.1','M9:30.2','M9:30.3'])

            m9301 = RPSP['Subturno'].value_counts().get('M9:30.1', 0)
            m9302 = RPSP['Subturno'].value_counts().get('M9:30.2', 0)
            m9303 = RPSP['Subturno'].value_counts().get('M9:30.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m9301,m9302,m9303])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            if not horas_dispo[horas_dispo['Accesibilidad'] == maximo].empty:
                maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
                planning.iloc[i,6] = maximo.loc['Subturno']
                planning.iloc[i,7] = maximo.loc['Hora']     

                posicion = maximo.loc['Hora']
                posicion = orden[orden['Hora'] == posicion]
                posicion = posicion.iloc[0,1]
                agentes[posicion] = agentes[posicion] - 1

                contestadas = agentes * productividad
                contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
                accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
                accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

                acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
                acc.iloc[:,0] = horas
                acc.iloc[:,1] = accesibilidad

            else:
                print("No rows found with the specified condition.")

        if planning.iloc[i,2] == 'T14' and planning.iloc[i,5] == "10'-30'-10'" and (planning.iloc[i,0] == 'RP/SP' or planning.iloc[i,0] == ' RP/SP' or planning.iloc[i,0] == '  RP/SP' or planning.iloc[i,0] == 'RP/SP ' or planning.iloc[i,0] == 'RP/SP  ' or planning.iloc[i,0] == 'RP/SP/cias'):
            cantidad = RPSP[dia].value_counts().get('T14',0)
            horas_dispo = pausas.loc[[33],['T14.1','T14.2','T14.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['T14.1','T14.2','T14.3'])

            t141 = RPSP['Subturno'].value_counts().get('T14.1', 0)
            t142 = RPSP['Subturno'].value_counts().get('T14.2', 0)
            t143 = RPSP['Subturno'].value_counts().get('T14.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [t141,t142,t143])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            if not horas_dispo[horas_dispo['Accesibilidad'] == maximo].empty:
                maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
                planning.iloc[i,6] = maximo.loc['Subturno']
                planning.iloc[i,7] = maximo.loc['Hora']     

                posicion = maximo.loc['Hora']
                posicion = orden[orden['Hora'] == posicion]
                posicion = posicion.iloc[0,1]
                agentes[posicion] = agentes[posicion] - 1

                contestadas = agentes * productividad
                contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
                accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
                accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

                acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
                acc.iloc[:,0] = horas
                acc.iloc[:,1] = accesibilidad

            else:
                print("No rows found with the specified condition.")


    #RP/SP/CP, RP/SP/CP/cias, RP/SP/CP/promos
    for i in range(len(planning['Nombre'])):
        RPSPCP = planning[planning['Línea'].isin(['RP/SP/CP',' RP/SP/CP','  RP/SP/CP','RP/SP/CP ','RP/SP/CP  ','RP/SP/CP/cias','RP/SP/CP/promos'])]
        if planning.iloc[i,2] == 'M7' and planning.iloc[i,5] == "10'-30'-10'" and (planning.iloc[i,0] == 'RP/SP/CP' or planning.iloc[i,0] == ' RP/SP/CP' or planning.iloc[i,0] == '  RP/SP/CP' or planning.iloc[i,0] == 'RP/SP/CP ' or planning.iloc[i,0] == 'RP/SP/CP  ' or planning.iloc[i,0] == 'RP/SP/CP/cias' or planning.iloc[i,0] == 'RP/SP/CP/promos'):
            cantidad = RPSPCP[dia].value_counts().get('M7',0)
            horas_dispo = pausas.loc[[33],['M7.1','M7.2','M7.3','M7.4','M7.5']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M7.1','M7.2','M7.3','M7.4','M7.5'])

            m71 = RPSPCP['Subturno'].value_counts().get('M7.1', 0)
            m72 = RPSPCP['Subturno'].value_counts().get('M7.2', 0)
            m73 = RPSPCP['Subturno'].value_counts().get('M7.3', 0)
            m74 = RPSPCP['Subturno'].value_counts().get('M7.4', 0)        
            m75 = RPSPCP['Subturno'].value_counts().get('M7.5', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m71,m72,m73,m74,m75])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            if not horas_dispo[horas_dispo['Accesibilidad'] == maximo].empty:
                maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
                planning.iloc[i,6] = maximo.loc['Subturno']
                planning.iloc[i,7] = maximo.loc['Hora']     

                posicion = maximo.loc['Hora']
                posicion = orden[orden['Hora'] == posicion]
                posicion = posicion.iloc[0,1]
                agentes[posicion] = agentes[posicion] - 1

                contestadas = agentes * productividad
                contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
                accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
                accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

                acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
                acc.iloc[:,0] = horas
                acc.iloc[:,1] = accesibilidad

            else:
                print("No rows found with the specified condition.")

        if planning.iloc[i,2] == 'M8' and (planning.iloc[i,0] == 'RP/SP/CP' or planning.iloc[i,0] == ' RP/SP/CP' or planning.iloc[i,0] == '  RP/SP/CP' or planning.iloc[i,0] == 'RP/SP/CP ' or planning.iloc[i,0] == 'RP/SP/CP  ' or planning.iloc[i,0] == 'RP/SP/CP/cias' or planning.iloc[i,0] == 'RP/SP/CP/promos'):
            cantidad = RPSPCP[dia].value_counts().get('M8',0)
            horas_dispo = pausas.loc[[33],['M8.1','M8.2','M8.3','M8.4','M8.5']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M8.1','M8.2','M8.3','M8.4','M8.5'])

            m81 = RPSPCP['Subturno'].value_counts().get('M8.1', 0)
            m82 = RPSPCP['Subturno'].value_counts().get('M8.2', 0)
            m83 = RPSPCP['Subturno'].value_counts().get('M8.3', 0)
            m84 = RPSPCP['Subturno'].value_counts().get('M8.4', 0)
            m85 = RPSPCP['Subturno'].value_counts().get('M8.5', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m81,m82,m83,m84,m85])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            if not horas_dispo[horas_dispo['Accesibilidad'] == maximo].empty:
                maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
                planning.iloc[i,6] = maximo.loc['Subturno']
                planning.iloc[i,7] = maximo.loc['Hora']     

                posicion = maximo.loc['Hora']
                posicion = orden[orden['Hora'] == posicion]
                posicion = posicion.iloc[0,1]
                agentes[posicion] = agentes[posicion] - 1

                contestadas = agentes * productividad
                contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
                accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
                accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

                acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
                acc.iloc[:,0] = horas
                acc.iloc[:,1] = accesibilidad

            else:
                print("No rows found with the specified condition.")

        if planning.iloc[i,2] == 'M9' and (planning.iloc[i,0] == 'RP/SP/CP' or planning.iloc[i,0] == ' RP/SP/CP' or planning.iloc[i,0] == '  RP/SP/CP' or planning.iloc[i,0] == 'RP/SP/CP ' or planning.iloc[i,0] == 'RP/SP/CP  ' or planning.iloc[i,0] == 'RP/SP/CP/cias' or planning.iloc[i,0] == 'RP/SP/CP/promos'):
            cantidad = RPSPCP[dia].value_counts().get('M9',0)
            horas_dispo = pausas.loc[[33],['M9.1','M9.2','M9.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M9.1','M9.2','M9.3'])

            m91 = RPSPCP['Subturno'].value_counts().get('M9.1', 0)
            m92 = RPSPCP['Subturno'].value_counts().get('M9.2', 0)
            m93 = RPSPCP['Subturno'].value_counts().get('M9.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m91,m92,m93])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            if not horas_dispo[horas_dispo['Accesibilidad'] == maximo].empty:
                maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
                planning.iloc[i,6] = maximo.loc['Subturno']
                planning.iloc[i,7] = maximo.loc['Hora']     

                posicion = maximo.loc['Hora']
                posicion = orden[orden['Hora'] == posicion]
                posicion = posicion.iloc[0,1]
                agentes[posicion] = agentes[posicion] - 1

                contestadas = agentes * productividad
                contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
                accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
                accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

                acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
                acc.iloc[:,0] = horas
                acc.iloc[:,1] = accesibilidad

            else:
                print("No rows found with the specified condition.")
        
        if planning.iloc[i,2] == 'M10' and (planning.iloc[i,0] == 'RP/SP/CP' or planning.iloc[i,0] == ' RP/SP/CP' or planning.iloc[i,0] == '  RP/SP/CP' or planning.iloc[i,0] == 'RP/SP/CP ' or planning.iloc[i,0] == 'RP/SP/CP  ' or planning.iloc[i,0] == 'RP/SP/CP/cias' or planning.iloc[i,0] == 'RP/SP/CP/promos'):
            cantidad = RPSPCP[dia].value_counts().get('M10',0)
            horas_dispo = pausas.loc[[33],['M10.1','M10.2','M10.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M10.1','M10.2','M10.3'])

            m101 = RPSPCP['Subturno'].value_counts().get('M10.1', 0)
            m102 = RPSPCP['Subturno'].value_counts().get('M10.2', 0)
            m103 = RPSPCP['Subturno'].value_counts().get('M10.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m101,m102,m103])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            if not horas_dispo[horas_dispo['Accesibilidad'] == maximo].empty:
                maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
                planning.iloc[i,6] = maximo.loc['Subturno']
                planning.iloc[i,7] = maximo.loc['Hora']     

                posicion = maximo.loc['Hora']
                posicion = orden[orden['Hora'] == posicion]
                posicion = posicion.iloc[0,1]
                agentes[posicion] = agentes[posicion] - 1

                contestadas = agentes * productividad
                contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
                accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
                accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

                acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
                acc.iloc[:,0] = horas
                acc.iloc[:,1] = accesibilidad

            else:
                print("No rows found with the specified condition.")

        if planning.iloc[i,2] == 'M12' and (planning.iloc[i,0] == 'RP/SP/CP' or planning.iloc[i,0] == ' RP/SP/CP' or planning.iloc[i,0] == '  RP/SP/CP' or planning.iloc[i,0] == 'RP/SP/CP ' or planning.iloc[i,0] == 'RP/SP/CP  ' or planning.iloc[i,0] == 'RP/SP/CP/cias' or planning.iloc[i,0] == 'RP/SP/CP/promos'):
            cantidad = RPSPCP[dia].value_counts().get('M12',0)
            horas_dispo = pausas.loc[[33],['M12.1','M12.2','M12.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M12.1','M12.2','M12.3'])

            m121 = RPSPCP['Subturno'].value_counts().get('M12.1', 0)
            m122 = RPSPCP['Subturno'].value_counts().get('M12.2', 0)
            m123 = RPSPCP['Subturno'].value_counts().get('M12.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m121,m122,m123])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            if not horas_dispo[horas_dispo['Accesibilidad'] == maximo].empty:
                maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
                planning.iloc[i,6] = maximo.loc['Subturno']
                planning.iloc[i,7] = maximo.loc['Hora']     

                posicion = maximo.loc['Hora']
                posicion = orden[orden['Hora'] == posicion]
                posicion = posicion.iloc[0,1]
                agentes[posicion] = agentes[posicion] - 1

                contestadas = agentes * productividad
                contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
                accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
                accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

                acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
                acc.iloc[:,0] = horas
                acc.iloc[:,1] = accesibilidad

            else:
                print("No rows found with the specified condition.")

        if planning.iloc[i,2] == 'T13' and (planning.iloc[i,0] == 'RP/SP/CP' or planning.iloc[i,0] == ' RP/SP/CP' or planning.iloc[i,0] == '  RP/SP/CP' or planning.iloc[i,0] == 'RP/SP/CP ' or planning.iloc[i,0] == 'RP/SP/CP  ' or planning.iloc[i,0] == 'RP/SP/CP/cias' or planning.iloc[i,0] == 'RP/SP/CP/promos'):
            cantidad = RPSPCP[dia].value_counts().get('T13',0)
            horas_dispo = pausas.loc[[33],['T13.1','T13.2','T13.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['T13.1','T13.2','T13.3'])

            t131 = RPSPCP['Subturno'].value_counts().get('T13.1', 0)
            t132 = RPSPCP['Subturno'].value_counts().get('T13.2', 0)
            t133 = RPSPCP['Subturno'].value_counts().get('T13.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [t131,t132,t133])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            if not horas_dispo[horas_dispo['Accesibilidad'] == maximo].empty:
                maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
                planning.iloc[i,6] = maximo.loc['Subturno']
                planning.iloc[i,7] = maximo.loc['Hora']     

                posicion = maximo.loc['Hora']
                posicion = orden[orden['Hora'] == posicion]
                posicion = posicion.iloc[0,1]
                agentes[posicion] = agentes[posicion] - 1

                contestadas = agentes * productividad
                contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
                accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
                accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

                acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
                acc.iloc[:,0] = horas
                acc.iloc[:,1] = accesibilidad

            else:
                print("No rows found with the specified condition.")

        if planning.iloc[i,2] == 'M9:30' and (planning.iloc[i,0] == 'RP/SP/CP' or planning.iloc[i,0] == ' RP/SP/CP' or planning.iloc[i,0] == '  RP/SP/CP' or planning.iloc[i,0] == 'RP/SP/CP ' or planning.iloc[i,0] == 'RP/SP/CP  ' or planning.iloc[i,0] == 'RP/SP/CP/cias' or planning.iloc[i,0] == 'RP/SP/CP/promos'):
            cantidad = RPSPCP[dia].value_counts().get('M9:30',0)
            horas_dispo = pausas.loc[[33],['M9:30.1','M9:30.2','M9:30.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M9:30.1','M9:30.2','M9:30.3'])

            m9301 = RPSPCP['Subturno'].value_counts().get('M9:30.1', 0)
            m9302 = RPSPCP['Subturno'].value_counts().get('M9:30.2', 0)
            m9303 = RPSPCP['Subturno'].value_counts().get('M9:30.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m9301,m9302,m9303])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            if not horas_dispo[horas_dispo['Accesibilidad'] == maximo].empty:
                maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
                planning.iloc[i,6] = maximo.loc['Subturno']
                planning.iloc[i,7] = maximo.loc['Hora']     

                posicion = maximo.loc['Hora']
                posicion = orden[orden['Hora'] == posicion]
                posicion = posicion.iloc[0,1]
                agentes[posicion] = agentes[posicion] - 1

                contestadas = agentes * productividad
                contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
                accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
                accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

                acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
                acc.iloc[:,0] = horas
                acc.iloc[:,1] = accesibilidad

            else:
                print("No rows found with the specified condition.")

        if (planning.iloc[i,2] == 'T14' or planning.iloc[i,2] == 'T14*' or planning.iloc[i,2] == '*T14') and planning.iloc[i,5] == "10'-30'-10'" and (planning.iloc[i,0] == 'RP/SP/CP' or planning.iloc[i,0] == ' RP/SP/CP' or planning.iloc[i,0] == '  RP/SP/CP' or planning.iloc[i,0] == 'RP/SP/CP ' or planning.iloc[i,0] == 'RP/SP/CP  ' or planning.iloc[i,0] == 'RP/SP/CP/cias' or planning.iloc[i,0] == 'RP/SP/CP/promos'):
            cantidad = RPSPCP[dia].value_counts().get('T14',0)
            horas_dispo = pausas.loc[[33],['T14.1','T14.2','T14.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['T14.1','T14.2','T14.3'])

            t141 = RPSPCP['Subturno'].value_counts().get('T14.1', 0)
            t142 = RPSPCP['Subturno'].value_counts().get('T14.2', 0)
            t143 = RPSPCP['Subturno'].value_counts().get('T14.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [t141,t142,t143])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            if not horas_dispo[horas_dispo['Accesibilidad'] == maximo].empty:
                maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
                planning.iloc[i,6] = maximo.loc['Subturno']
                planning.iloc[i,7] = maximo.loc['Hora']     

                posicion = maximo.loc['Hora']
                posicion = orden[orden['Hora'] == posicion]
                posicion = posicion.iloc[0,1]
                agentes[posicion] = agentes[posicion] - 1

                contestadas = agentes * productividad
                contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
                accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
                accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

                acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
                acc.iloc[:,0] = horas
                acc.iloc[:,1] = accesibilidad

            else:
                print("No rows found with the specified condition.")


    #SP/CP, SP/CP/promos
    for i in range(len(planning['Nombre'])):
        SPCP = planning[planning['Línea'].isin(['SP/CP',' SP/CP','  SP/CP','SP/CP ','SP/CP  ','SP/CP/promos'])]
        if planning.iloc[i,2] == 'M7' and planning.iloc[i,5] == "10'-30'-10'" and (planning.iloc[i,0] == 'SP/CP' or planning.iloc[i,0] == ' SP/CP' or planning.iloc[i,0] == '  SP/CP' or planning.iloc[i,0] == 'SP/CP ' or planning.iloc[i,0] == 'SP/CP  ' or planning.iloc[i,0] == 'SP/CP/promos'):
            cantidad = SPCP[dia].value_counts().get('M7',0)
            horas_dispo = pausas.loc[[33],['M7.1','M7.2','M7.3','M7.4','M7.5']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M7.1','M7.2','M7.3','M7.4','M7.5'])

            m71 = SPCP['Subturno'].value_counts().get('M7.1', 0)
            m72 = SPCP['Subturno'].value_counts().get('M7.2', 0)
            m73 = SPCP['Subturno'].value_counts().get('M7.3', 0)
            m74 = SPCP['Subturno'].value_counts().get('M7.4', 0)        
            m75 = SPCP['Subturno'].value_counts().get('M7.5', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m71,m72,m73,m74,m75])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            if not horas_dispo[horas_dispo['Accesibilidad'] == maximo].empty:
                maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
                planning.iloc[i,6] = maximo.loc['Subturno']
                planning.iloc[i,7] = maximo.loc['Hora']     

                posicion = maximo.loc['Hora']
                posicion = orden[orden['Hora'] == posicion]
                posicion = posicion.iloc[0,1]
                agentes[posicion] = agentes[posicion] - 1

                contestadas = agentes * productividad
                contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
                accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
                accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

                acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
                acc.iloc[:,0] = horas
                acc.iloc[:,1] = accesibilidad

            else:
                print("No rows found with the specified condition.")

        if planning.iloc[i,2] == 'M8' and (planning.iloc[i,0] == 'SP/CP' or planning.iloc[i,0] == ' SP/CP' or planning.iloc[i,0] == '  SP/CP' or planning.iloc[i,0] == 'SP/CP ' or planning.iloc[i,0] == 'SP/CP  ' or planning.iloc[i,0] == 'SP/CP/promos'):
            cantidad = SPCP[dia].value_counts().get('M8',0)
            horas_dispo = pausas.loc[[33],['M8.1','M8.2','M8.3','M8.4','M8.5']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M8.1','M8.2','M8.3','M8.4','M8.5'])

            m81 = SPCP['Subturno'].value_counts().get('M8.1', 0)
            m82 = SPCP['Subturno'].value_counts().get('M8.2', 0)
            m83 = SPCP['Subturno'].value_counts().get('M8.3', 0)
            m84 = SPCP['Subturno'].value_counts().get('M8.4', 0)
            m85 = SPCP['Subturno'].value_counts().get('M8.5', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m81,m82,m83,m84,m85])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()

            if not horas_dispo[horas_dispo['Accesibilidad'] == maximo].empty:
                maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
                planning.iloc[i,6] = maximo.loc['Subturno']
                planning.iloc[i,7] = maximo.loc['Hora']     

                posicion = maximo.loc['Hora']
                posicion = orden[orden['Hora'] == posicion]
                posicion = posicion.iloc[0,1]
                agentes[posicion] = agentes[posicion] - 1

                contestadas = agentes * productividad
                contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
                accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
                accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

                acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
                acc.iloc[:,0] = horas
                acc.iloc[:,1] = accesibilidad

            else:
                print("No rows found with the specified condition.")

        if planning.iloc[i,2] == 'M9' and (planning.iloc[i,0] == 'SP/CP' or planning.iloc[i,0] == ' SP/CP' or planning.iloc[i,0] == '  SP/CP' or planning.iloc[i,0] == 'SP/CP ' or planning.iloc[i,0] == 'SP/CP  ' or planning.iloc[i,0] == 'SP/CP/promos'):
            cantidad = SPCP[dia].value_counts().get('M9',0)
            horas_dispo = pausas.loc[[33],['M9.1','M9.2','M9.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M9.1','M9.2','M9.3'])

            m91 = SPCP['Subturno'].value_counts().get('M9.1', 0)
            m92 = SPCP['Subturno'].value_counts().get('M9.2', 0)
            m93 = SPCP['Subturno'].value_counts().get('M9.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m91,m92,m93])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            if not horas_dispo[horas_dispo['Accesibilidad'] == maximo].empty:
                maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
                planning.iloc[i,6] = maximo.loc['Subturno']
                planning.iloc[i,7] = maximo.loc['Hora']     

                posicion = maximo.loc['Hora']
                posicion = orden[orden['Hora'] == posicion]
                posicion = posicion.iloc[0,1]
                agentes[posicion] = agentes[posicion] - 1

                contestadas = agentes * productividad
                contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
                accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
                accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

                acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
                acc.iloc[:,0] = horas
                acc.iloc[:,1] = accesibilidad

            else:
                print("No rows found with the specified condition.")
        
        if planning.iloc[i,2] == 'M10' and (planning.iloc[i,0] == 'SP/CP' or planning.iloc[i,0] == ' SP/CP' or planning.iloc[i,0] == '  SP/CP' or planning.iloc[i,0] == 'SP/CP ' or planning.iloc[i,0] == 'SP/CP  ' or planning.iloc[i,0] == 'SP/CP/promos'):
            cantidad = SPCP[dia].value_counts().get('M10',0)
            horas_dispo = pausas.loc[[33],['M10.1','M10.2','M10.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M10.1','M10.2','M10.3'])

            m101 = SPCP['Subturno'].value_counts().get('M10.1', 0)
            m102 = SPCP['Subturno'].value_counts().get('M10.2', 0)
            m103 = SPCP['Subturno'].value_counts().get('M10.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m101,m102,m103])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            if not horas_dispo[horas_dispo['Accesibilidad'] == maximo].empty:
                maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
                planning.iloc[i,6] = maximo.loc['Subturno']
                planning.iloc[i,7] = maximo.loc['Hora']     

                posicion = maximo.loc['Hora']
                posicion = orden[orden['Hora'] == posicion]
                posicion = posicion.iloc[0,1]
                agentes[posicion] = agentes[posicion] - 1

                contestadas = agentes * productividad
                contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
                accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
                accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

                acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
                acc.iloc[:,0] = horas
                acc.iloc[:,1] = accesibilidad

            else:
                print("No rows found with the specified condition.")

        if planning.iloc[i,2] == 'M12' and (planning.iloc[i,0] == 'SP/CP' or planning.iloc[i,0] == ' SP/CP' or planning.iloc[i,0] == '  SP/CP' or planning.iloc[i,0] == 'SP/CP ' or planning.iloc[i,0] == 'SP/CP  ' or planning.iloc[i,0] == 'SP/CP/promos'):
            cantidad = SPCP[dia].value_counts().get('M12',0)
            horas_dispo = pausas.loc[[33],['M12.1','M12.2','M12.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M12.1','M12.2','M12.3'])

            m121 = SPCP['Subturno'].value_counts().get('M12.1', 0)
            m122 = SPCP['Subturno'].value_counts().get('M12.2', 0)
            m123 = SPCP['Subturno'].value_counts().get('M12.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m121,m122,m123])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            if not horas_dispo[horas_dispo['Accesibilidad'] == maximo].empty:
                maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
                planning.iloc[i,6] = maximo.loc['Subturno']
                planning.iloc[i,7] = maximo.loc['Hora']     

                posicion = maximo.loc['Hora']
                posicion = orden[orden['Hora'] == posicion]
                posicion = posicion.iloc[0,1]
                agentes[posicion] = agentes[posicion] - 1

                contestadas = agentes * productividad
                contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
                accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
                accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

                acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
                acc.iloc[:,0] = horas
                acc.iloc[:,1] = accesibilidad

            else:
                print("No rows found with the specified condition.")

        if planning.iloc[i,2] == 'T13' and (planning.iloc[i,0] == 'SP/CP' or planning.iloc[i,0] == ' SP/CP' or planning.iloc[i,0] == '  SP/CP' or planning.iloc[i,0] == 'SP/CP ' or planning.iloc[i,0] == 'SP/CP  ' or planning.iloc[i,0] == 'SP/CP/promos'):
            cantidad = SPCP[dia].value_counts().get('T13',0)
            horas_dispo = pausas.loc[[33],['T13.1','T13.2','T13.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['T13.1','T13.2','T13.3'])

            t131 = SPCP['Subturno'].value_counts().get('T13.1', 0)
            t132 = SPCP['Subturno'].value_counts().get('T13.2', 0)
            t133 = SPCP['Subturno'].value_counts().get('T13.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [t131,t132,t133])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            if not horas_dispo[horas_dispo['Accesibilidad'] == maximo].empty:
                maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
                planning.iloc[i,6] = maximo.loc['Subturno']
                planning.iloc[i,7] = maximo.loc['Hora']     

                posicion = maximo.loc['Hora']
                posicion = orden[orden['Hora'] == posicion]
                posicion = posicion.iloc[0,1]
                agentes[posicion] = agentes[posicion] - 1

                contestadas = agentes * productividad
                contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
                accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
                accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

                acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
                acc.iloc[:,0] = horas
                acc.iloc[:,1] = accesibilidad

            else:
                print("No rows found with the specified condition.")

        if planning.iloc[i,2] == 'M9:30' and (planning.iloc[i,0] == 'SP/CP' or planning.iloc[i,0] == ' SP/CP' or planning.iloc[i,0] == '  SP/CP' or planning.iloc[i,0] == 'SP/CP ' or planning.iloc[i,0] == 'SP/CP  ' or planning.iloc[i,0] == 'SP/CP/promos'):
            cantidad = SPCP[dia].value_counts().get('M9:30',0)
            horas_dispo = pausas.loc[[33],['M9:30.1','M9:30.2','M9:30.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['M9:30.1','M9:30.2','M9:30.3'])

            m9301 = SPCP['Subturno'].value_counts().get('M9:30.1', 0)
            m9302 = SPCP['Subturno'].value_counts().get('M9:30.2', 0)
            m9303 = SPCP['Subturno'].value_counts().get('M9:30.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [m9301,m9302,m9303])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            if not horas_dispo[horas_dispo['Accesibilidad'] == maximo].empty:
                maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
                planning.iloc[i,6] = maximo.loc['Subturno']
                planning.iloc[i,7] = maximo.loc['Hora']     

                posicion = maximo.loc['Hora']
                posicion = orden[orden['Hora'] == posicion]
                posicion = posicion.iloc[0,1]
                agentes[posicion] = agentes[posicion] - 1

                contestadas = agentes * productividad
                contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
                accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
                accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

                acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
                acc.iloc[:,0] = horas
                acc.iloc[:,1] = accesibilidad

            else:
                print("No rows found with the specified condition.")

        if planning.iloc[i,2] == 'T14' and planning.iloc[i,5] == "10'-30'-10'" and (planning.iloc[i,0] == 'SP/CP' or planning.iloc[i,0] == ' SP/CP' or planning.iloc[i,0] == '  SP/CP' or planning.iloc[i,0] == 'SP/CP ' or planning.iloc[i,0] == 'SP/CP  ' or planning.iloc[i,0] == 'SP/CP/promos'):
            cantidad = SPCP[dia].value_counts().get('T14',0)
            horas_dispo = pausas.loc[[33],['T14.1','T14.2','T14.3']]
            horas_dispo.index = ['Hora']
            horas_dispo = acc.loc[acc['Hora'].isin(horas_dispo.iloc[0])]
            horas_dispo = horas_dispo.assign(Subturno = ['T14.1','T14.2','T14.3'])

            t141 = SPCP['Subturno'].value_counts().get('T14.1', 0)
            t142 = SPCP['Subturno'].value_counts().get('T14.2', 0)
            t143 = SPCP['Subturno'].value_counts().get('T14.3', 0)

            horas_dispo = horas_dispo.assign(Frecuencia = [t141,t142,t143])
            if cantidad > 1:
                horas_dispo = horas_dispo[horas_dispo['Frecuencia'] < cantidad / 2]

            maximo = horas_dispo['Accesibilidad'].max()
            if not horas_dispo[horas_dispo['Accesibilidad'] == maximo].empty:
                maximo = horas_dispo[horas_dispo['Accesibilidad'] == maximo].iloc[0]
                planning.iloc[i,6] = maximo.loc['Subturno']
                planning.iloc[i,7] = maximo.loc['Hora']     

                posicion = maximo.loc['Hora']
                posicion = orden[orden['Hora'] == posicion]
                posicion = posicion.iloc[0,1]
                agentes[posicion] = agentes[posicion] - 1

                contestadas = agentes * productividad
                contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
                accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
                accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100

                acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
                acc.iloc[:,0] = horas
                acc.iloc[:,1] = accesibilidad

            else:
                print("No rows found with the specified condition.")





    # Breaks P9:30
    planning = planning.assign(Break1 = np.zeros((len(planning['Nombre']),1)))
    planning = planning.assign(Break2 = np.zeros((len(planning['Nombre']),1)))

    break1 = pausas.loc[32,'P9:30']
    break2 = pausas.loc[34,'P9:30']

    for i in range(len(planning['Nombre'])):
        if planning.loc[i,dia] == 'P9:30':
            planning.loc[i,'Break1'] = (datetime.combine(datetime.today(), break1) + timedelta(minutes=random.choice([0,10,20,30,40]))).time()
            planning.loc[i,'Break2'] = (datetime.combine(datetime.today(), break2) + timedelta(minutes=random.choice([0,10,20,30,40]))).time()



    # Breaks P9:00
    break1 = pausas.loc[32,'P9:00']
    break2 = pausas.loc[34,'P9:00']

    for i in range(len(planning['Nombre'])):
        if planning.loc[i,dia] == 'P9:00':
            planning.loc[i,'Break1'] = (datetime.combine(datetime.today(), break1) + timedelta(minutes=random.choice([0,10,20,30,40]))).time()
            planning.loc[i,'Break2'] = (datetime.combine(datetime.today(), break2) + timedelta(minutes=random.choice([0,10,20,30,40]))).time()

    # Creo columnas Lunch2 y Lunch3
    
    planning = planning.assign(Lunch2 = np.zeros((len(planning['Nombre']),1)))
    planning = planning.assign(Lunch3 = np.zeros((len(planning['Nombre']),1)))

    # Breaks M7
    for i in range(len(planning['Nombre'])):
        if planning.loc[i,dia] == 'M7' and planning.loc[i,'Preferencia'] == 1:
            planning.loc[i,'Subturno'] = 'M7.0.1'
            break1 = time(9,20,00)
            planning.loc[i,'Break1'] = (datetime.combine(datetime.today(), break1) + timedelta(minutes=random.choice([0,10,20]))).time()
            if planning.loc[i,'Break1'] == time(9,20,00):
                planning.loc[i,'Break2'] = time(12,10,00)
            if planning.loc[i,'Break1'] == time(9,30,00):
                planning.loc[i,'Break2'] = time(12,20,00)
            if planning.loc[i,'Break1'] == time(9,40,00):
                planning.loc[i,'Break2'] = time(12,30,00)


        if planning.loc[i,dia] == 'M7' and planning.loc[i,'Preferencia'] == 2:
            lunch = time(10,40,00)
            planning.loc[i,'Subturno'] = 'M7.0.2'
            planning.loc[i,'Lunch'] = (datetime.combine(datetime.today(), lunch) + timedelta(minutes=random.choice([0,10,20,30,40]))).time()
            planning.loc[i,'Lunch2'] = (datetime.combine(datetime.today(), planning.loc[i,'Lunch']) + timedelta(minutes=10)).time()



    # Breaks T14
    for i in range(len(planning['Nombre'])):
        if planning.loc[i,dia] == 'T14' and planning.loc[i,'Preferencia'] == 1:
            planning.loc[i,'Subturno'] = 'T14.0.1'
            break1 = time(16,20,00)
            planning.loc[i,'Break1'] = (datetime.combine(datetime.today(), break1) + timedelta(minutes=random.choice([0,10,20]))).time()
            if planning.loc[i,'Break1'] == time(16,20,00):
                planning.loc[i,'Break2'] = time(19,10,00)
            if planning.loc[i,'Break1'] == time(16,30,00):
                planning.loc[i,'Break2'] = time(19,20,00)
            if planning.loc[i,'Break1'] == time(16,40,00):
                planning.loc[i,'Break2'] = time(19,30,00)

        if planning.loc[i,dia] == 'T14' and planning.loc[i,'Preferencia'] == 2:
            lunch = time(16,40,00)
            planning.loc[i,'Subturno'] = 'T14.0.2'
            planning.loc[i,'Lunch'] = (datetime.combine(datetime.today(), lunch) + timedelta(minutes=random.choice([0,10,20,30,40]))).time()
            planning.loc[i,'Lunch2'] = (datetime.combine(datetime.today(), planning.loc[i,'Lunch']) + timedelta(minutes=10)).time()





    # Resto de breaks
    resto_turnos = ['M7.1','M7.2','M7.3','M7.4','M7.5','M8.1','M8.2','M8.3','M8.4','M8.5','M9.1','M9.2','M9.3','M10.1','M10.2','M10.3','M12.1','M12.2','M12.3','T13.1','T13.2','T13.3','T14.1','T14.2','T14.3','M9:30.1','M9:30.2','M9:30.3']

    for i in range(len(planning['Nombre'])):
        for j in resto_turnos:
            if planning.loc[i,'Subturno'] == j:
                planning.loc[i,'Break1'] = pausas.loc[32,j]

    for i in range(len(planning['Nombre'])):
        for j in resto_turnos:
            if planning.loc[i,'Subturno'] == j:
                planning.loc[i,'Break2'] = pausas.loc[34,j]

    # Casos especiales
                
    especiales = pd.read_excel('U:\Turnos\Horarios y pausas\Definitivo\Turnos especiales.xlsx', sheet_name= 'Hoja1')

        # Nuria Martín
    
    nombre = 'MARTIN  OTERO, NURIA'
    if nombre in planning['Nombre'].values:
            # Primero saco la hora de lunch que le he puesto antes al agente, del array agentes busco la cantidad de agentes a esa hora y le sumo 1
        
        lunch_viejo = planning.loc[planning['Nombre'] == 'MARTIN  OTERO, NURIA', 'Lunch'].values[0]
        posicion = orden.loc[orden['Hora'] == lunch_viejo, 'Numero'].values[0]
        agentes[posicion] = agentes[posicion] + 1

            # De una tabla con los turnos especiales, busco la hora que tiene que parar y resto un agente a esa hora en el array agentes
        
        lunch_esp = especiales.loc[especiales['Agente'] == 'MARTIN  OTERO, NURIA']
        turno = planning.loc[planning['Nombre'] == 'MARTIN  OTERO, NURIA', dia].values[0]
        lunch_esp = lunch_esp.loc[lunch_esp['Turno'] == turno, 'Lunch'].values[0]
        posicion = orden.loc[orden['Hora'] == lunch_esp, 'Numero'].values[0]
        agentes[posicion] = agentes[posicion] - 1
        
            # Actualizo los arrays contestadas, accesibilidad, accesibilidad_dia y acc y actualizo las columnas Subturno y Hora del dataframe planning

        contestadas = agentes * productividad
        contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
        accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
        accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100
        acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
        acc.iloc[:,0] = horas
        acc.iloc[:,1] = accesibilidad
        planning.loc[planning['Nombre'] == 'MARTIN  OTERO, NURIA', 'Lunch'] = lunch_esp

            # Actualizo breaks
        
        break1_esp = especiales.loc[especiales['Agente'] == 'MARTIN  OTERO, NURIA']
        break1_esp = break1_esp.loc[break1_esp['Turno'] == turno, 'Break 1'].values[0]
        planning.loc[planning['Nombre'] == 'MARTIN  OTERO, NURIA', 'Break1'] = break1_esp

        break2_esp = especiales.loc[especiales['Agente'] == 'MARTIN  OTERO, NURIA']
        break2_esp = break2_esp.loc[break2_esp['Turno'] == turno, 'Break 2'].values[0]
        planning.loc[planning['Nombre'] == 'MARTIN  OTERO, NURIA', 'Break2'] = break2_esp

            # Resto la hora que no está
        
        if turno == 'M7':
            agentes[15] -= 1
            agentes[16] -= 1
        elif turno == 'M8':
            agentes[17] -= 1
            agentes[18] -= 1
        elif turno == 'M9':
            agentes[19] -= 1
            agentes[20] -= 1
        elif turno == 'M9:30':
            agentes[20] -= 1
            agentes[21] -= 1
        elif turno == 'M10':
            agentes[21] -= 1
            agentes[22] -= 1
        elif turno == 'M12':
            agentes[25] -= 1
            agentes[26] -= 1
        elif turno == 'T13':
            agentes[27] -= 1
            agentes[28] -= 1
        elif turno == 'T14':
            agentes[13] -= 1
            agentes[14] -= 1



        # Rita Paustian

    nombre = 'PAUSTIAN-VOSS,RITA BIRKE '
    if nombre in planning['Nombre'].values:

        turno = planning.loc[planning['Nombre'] == 'PAUSTIAN-VOSS,RITA BIRKE ', dia].values[0]

        if turno != 'P9:30' and turno != 'P9:00' and dia.weekday() != 5 and dia.weekday() != 6 and turno != 'M7' and turno != 'T14':
            lunch_viejo = planning.loc[planning['Nombre'] == 'PAUSTIAN-VOSS,RITA BIRKE ', 'Lunch'].values[0]
            posicion = orden.loc[orden['Hora'] == lunch_viejo, 'Numero'].values[0]
            agentes[posicion] = agentes[posicion] + 1

                # Actualizo los arrays contestadas, accesibilidad, accesibilidad_dia y acc y actualizo las columnas Subturno y Hora del dataframe planning
                # Rita no hace lunch si no hace partido o no hace finde, así que le quito la hora de lunch de planning

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100
            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad
            planning.loc[planning['Nombre'] == 'PAUSTIAN-VOSS,RITA BIRKE ', 'Lunch'] = time(0, 0, 0)

                # Actualizo breaks (no hace break 2)
            
            break1_esp = especiales.loc[especiales['Agente'] == 'PAUSTIAN-VOSS,RITA BIRKE ']
            break1_esp = break1_esp.loc[break1_esp['Turno'] == turno, 'Break 1'].values[0]
            planning.loc[planning['Nombre'] == 'PAUSTIAN-VOSS,RITA BIRKE ', 'Break1'] = break1_esp

            planning.loc[planning['Nombre'] == 'PAUSTIAN-VOSS,RITA BIRKE ', 'Break2'] = time(0,0,0)

                # Resto la hora que no está

        if turno == 'M7':
            for i in range(8,17):
                agentes[i] -= 1
        elif turno == 'M8':
            for i in range(10,19):
                agentes[i] -= 1
        elif turno == 'M9':
            for i in range(12,21):
                agentes[i] -= 1
        elif turno == 'M10':
            for i in range(14,23):
                agentes[i] -= 1
        elif turno == 'M12':
            for i in range(18,27):
                agentes[i] -= 1



        # Tamara Nietlispach
                    # Tamara tiene un día a la semana que hace 6h y se indica con un asterisco. No hace pausa de 30min

    nombre = 'NIETLISPACH, TAMARA'
    if nombre in planning['Nombre'].values:
        turno = planning.loc[planning['Nombre'] == 'NIETLISPACH, TAMARA', dia].values[0]
        lunch_esp3 = especiales.loc[especiales['Agente'] == 'NIETLISPACH, TAMARA']
        lunch_esp3 = lunch_esp3.loc[lunch_esp3['Turno'] == turno, 'Lunch'].values[0]
        if '*' not in turno:
            lunch_viejo = planning.loc[planning['Nombre'] == 'NIETLISPACH, TAMARA', 'Lunch'].values[0]
            posicion = orden.loc[orden['Hora'] == lunch_viejo, 'Numero'].values[0]
            agentes[posicion] = agentes[posicion] + 1
            posicion = orden.loc[orden['Hora'] == lunch_esp3, 'Numero'].values[0]
            agentes[posicion] = agentes[posicion] - 1
            
                # Actualizo los arrays contestadas, accesibilidad, accesibilidad_dia y acc

        contestadas = agentes * productividad
        contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
        accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
        accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100
        acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
        acc.iloc[:,0] = horas
        acc.iloc[:,1] = accesibilidad

                # Actualizo breaks y lunch
        
        planning.loc[planning['Nombre'] == 'NIETLISPACH, TAMARA', 'Lunch'] = lunch_esp3
        
        break1_esp = especiales.loc[especiales['Agente'] == 'NIETLISPACH, TAMARA']
        break1_esp = break1_esp.loc[break1_esp['Turno'] == turno, 'Break 1'].values[0]
        planning.loc[planning['Nombre'] == 'NIETLISPACH, TAMARA', 'Break1'] = break1_esp

        break2_esp = especiales.loc[especiales['Agente'] == 'NIETLISPACH, TAMARA']
        break2_esp = break2_esp.loc[break2_esp['Turno'] == turno, 'Break 2'].values[0]
        planning.loc[planning['Nombre'] == 'NIETLISPACH, TAMARA', 'Break2'] = break2_esp

                # Resto las dos horas que no está cuando tiene un * en el turno
        
        if turno == 'M7*':
            agentes[13] -= 1
            agentes[14] -= 1
            agentes[15] -= 1
            agentes[16] -= 1
        elif turno == 'M8*':
            agentes[15] -= 1
            agentes[16] -= 1
            agentes[17] -= 1
            agentes[18] -= 1
        elif turno == 'M9*':
            agentes[17] -= 1
            agentes[18] -= 1
            agentes[19] -= 1
            agentes[20] -= 1
        elif turno == 'M9:30*':
            agentes[18] -= 1
            agentes[19] -= 1
            agentes[20] -= 1
            agentes[21] -= 1
        elif turno == 'M10*':
            agentes[19] -= 1
            agentes[20] -= 1
            agentes[21] -= 1
            agentes[22] -= 1
        elif turno == 'M12*':
            agentes[23] -= 1
            agentes[24] -= 1
            agentes[25] -= 1
            agentes[26] -= 1
        elif turno == 'T13*':
            agentes[25] -= 1
            agentes[26] -= 1
            agentes[27] -= 1
            agentes[28] -= 1
        elif turno == 'T14*' or turno == '*T14':
            agentes[14] -= 1
            agentes[15] -= 1
            agentes[16] -= 1
            agentes[17] -= 1

        # Katharina Winkel

    nombre = 'WINKEL, KATHARINA'
    if nombre in planning['Nombre'].values:
        turno = planning.loc[planning['Nombre'] == 'WINKEL, KATHARINA', dia].values[0]
        lunch_viejo = planning.loc[planning['Nombre'] == 'WINKEL, KATHARINA', 'Lunch'].values[0]
        posicion = orden.loc[orden['Hora'] == lunch_viejo, 'Numero'].values[0]
        agentes[posicion] = agentes[posicion] + 1

                # No hace lunch
        
        planning.loc[planning['Nombre'] == 'WINKEL, KATHARINA', 'Lunch'] = time(0, 0, 0)
        
                # Actualizo los arrays contestadas, accesibilidad, accesibilidad_dia y acc y actualizo las columnas Subturno y Hora del dataframe planning

        contestadas = agentes * productividad
        contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
        accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
        accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100
        acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
        acc.iloc[:,0] = horas
        acc.iloc[:,1] = accesibilidad

                # Actualizo breaks
        
        break1_esp = especiales.loc[especiales['Agente'] == 'WINKEL, KATHARINA']
        break1_esp = break1_esp.loc[break1_esp['Turno'] == turno, 'Break 1'].values[0]
        planning.loc[planning['Nombre'] == 'WINKEL, KATHARINA', 'Break1'] = break1_esp

        planning.loc[planning['Nombre'] == 'WINKEL, KATHARINA', 'Break2'] = time(0,0,0)    

                # Resto la hora que no está
        
        if turno == 'M7':
            agentes[14] -= 1
            agentes[15] -= 1
            agentes[16] -= 1
        elif turno == 'M8':
            agentes[16] -= 1
            agentes[17] -= 1
            agentes[18] -= 1
        elif turno == 'M9':
            agentes[18] -= 1
            agentes[19] -= 1
            agentes[20] -= 1
        elif turno == 'M9:30':
            agentes[19] -= 1
            agentes[20] -= 1
            agentes[21] -= 1
        elif turno == 'M10':
            agentes[20] -= 1
            agentes[21] -= 1
            agentes[22] -= 1
        elif turno == 'M12':
            agentes[24] -= 1
            agentes[25] -= 1
            agentes[26] -= 1
        elif turno == 'T13':
            agentes[26] -= 1
            agentes[27] -= 1
            agentes[28] -= 1
        elif turno == 'T14':
            agentes[13] -= 1
            agentes[14] -= 1
            agentes[15] -= 1


        # Romel Alvarado
            
    nombre = 'ALVARADO ROMAN, ROMEL GINO'
    if nombre in planning['Nombre'].values:

        turno = planning.loc[planning['Nombre'] == 'ALVARADO ROMAN, ROMEL GINO', dia].values[0]

        if turno == 'M7':
            lunch_viejo = planning.loc[planning['Nombre'] == 'ALVARADO ROMAN, ROMEL GINO', 'Lunch'].values[0]
            posicion = orden.loc[orden['Hora'] == lunch_viejo, 'Numero'].values[0]
            agentes[posicion] = agentes[posicion] + 1
            posicion = orden.loc[orden['Hora'] == time(12,0,0), 'Numero'].values[0]
            agentes[posicion] = agentes[posicion] - 1

                # Actualizo los arrays contestadas, accesibilidad, accesibilidad_dia y acc y actualizo las columnas Subturno y Hora del dataframe planning

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100
            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad
            planning.loc[planning['Nombre'] == 'ALVARADO ROMAN, ROMEL GINO', 'Lunch'] = time(12, 0, 0)

                # Actualizo breaks
            planning.loc[planning['Nombre'] == 'ALVARADO ROMAN, ROMEL GINO', 'Break1'] = time(9,30,0)
            planning.loc[planning['Nombre'] == 'ALVARADO ROMAN, ROMEL GINO', 'Break2'] = time(14,0,0)

        # Manuela Martínez (20' a las 10:30h en M7, 20' a las 18:00h en T14, lunch entre las 13:30 y las 14:30 en otro turno)
            
    nombre = 'MARTINEZ CANO, MANUELA'
    if nombre in planning['Nombre'].values:

        turno = planning.loc[planning['Nombre'] == nombre, dia].values[0]

        if turno == 'M7':
            posicion = orden.loc[orden['Hora'] == time(10,30,0), 'Numero'].values[0]
            agentes[posicion] = agentes[posicion] - 1

                # Actualizo los arrays contestadas, accesibilidad, accesibilidad_dia y acc y actualizo las columnas Subturno y Hora del dataframe planning

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100
            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad
            planning.loc[planning['Nombre'] == nombre, 'Lunch'] = time(10, 30, 0)
            planning.loc[planning['Nombre'] == nombre, 'Lunch2'] = time(10, 40, 0)
            planning.loc[planning['Nombre'] == nombre, 'Lunch3'] = time(0,0,0)
            

                # Actualizo breaks
            planning.loc[planning['Nombre'] == nombre, 'Break1'] = time(0,0,0)
            planning.loc[planning['Nombre'] == nombre, 'Break2'] = time(0,0,0)


        if turno == 'T14':
            agentes[posicion] = agentes[posicion] + 1
            posicion = orden.loc[orden['Hora'] == time(18,0,0), 'Numero'].values[0]
            agentes[posicion] = agentes[posicion] - 1

                # Actualizo los arrays contestadas, accesibilidad, accesibilidad_dia y acc y actualizo las columnas Subturno y Hora del dataframe planning

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100
            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad
            planning.loc[planning['Nombre'] == nombre, 'Lunch'] = time(18, 0, 0)
            planning.loc[planning['Nombre'] == nombre, 'Lunch2'] = time(18, 10, 0)
            planning.loc[planning['Nombre'] == nombre, 'Lunch3'] = time(0,0,0)
            

                # Actualizo breaks
            planning.loc[planning['Nombre'] == nombre, 'Break1'] = time(0,0,0)
            planning.loc[planning['Nombre'] == nombre, 'Break2'] = time(0,0,0)

        if turno == 'M8':
            lunch_viejo = planning.loc[planning['Nombre'] == nombre, 'Lunch'].values[0]
            posicion = orden.loc[orden['Hora'] == lunch_viejo, 'Numero'].values[0]
            agentes[posicion] = agentes[posicion] + 1
            posicion = orden.loc[orden['Hora'] == time(13,30,0), 'Numero'].values[0]
            agentes[posicion] = agentes[posicion] - 1

                # Actualizo los arrays contestadas, accesibilidad, accesibilidad_dia y acc y actualizo las columnas Subturno y Hora del dataframe planning

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100
            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad
            planning.loc[planning['Nombre'] == nombre, 'Lunch'] = time(13, 30, 0)
            

                # Actualizo breaks
            planning.loc[planning['Nombre'] == nombre, 'Break1'] = time(10,20,0)
            planning.loc[planning['Nombre'] == nombre, 'Break2'] = time(15,20,0)


        if turno == 'M9':
            lunch_viejo = planning.loc[planning['Nombre'] == nombre, 'Lunch'].values[0]
            posicion = orden.loc[orden['Hora'] == lunch_viejo, 'Numero'].values[0]
            agentes[posicion] = agentes[posicion] + 1
            posicion = orden.loc[orden['Hora'] == time(13,30,0), 'Numero'].values[0]
            agentes[posicion] = agentes[posicion] - 1

                # Actualizo los arrays contestadas, accesibilidad, accesibilidad_dia y acc y actualizo las columnas Subturno y Hora del dataframe planning

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100
            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad
            planning.loc[planning['Nombre'] == nombre, 'Lunch'] = time(13, 30, 0)
            

                # Actualizo breaks
            planning.loc[planning['Nombre'] == nombre, 'Break1'] = time(10,40,0)
            planning.loc[planning['Nombre'] == nombre, 'Break2'] = time(16,10,0)


        if turno == 'M12':
            lunch_viejo = planning.loc[planning['Nombre'] == nombre, 'Lunch'].values[0]
            posicion = orden.loc[orden['Hora'] == lunch_viejo, 'Numero'].values[0]
            agentes[posicion] = agentes[posicion] + 1
            posicion = orden.loc[orden['Hora'] == time(14,0,0), 'Numero'].values[0]
            agentes[posicion] = agentes[posicion] - 1

                # Actualizo los arrays contestadas, accesibilidad, accesibilidad_dia y acc y actualizo las columnas Subturno y Hora del dataframe planning

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100
            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad
            planning.loc[planning['Nombre'] == nombre, 'Lunch'] = time(14, 0, 0)
            

                # Actualizo breaks
            planning.loc[planning['Nombre'] == nombre, 'Break1'] = time(16,20,0)
            planning.loc[planning['Nombre'] == nombre, 'Break2'] = time(18,40,0)

        if turno == 'T13':
            lunch_viejo = planning.loc[planning['Nombre'] == nombre, 'Lunch'].values[0]
            posicion = orden.loc[orden['Hora'] == lunch_viejo, 'Numero'].values[0]
            agentes[posicion] = agentes[posicion] + 1
            posicion = orden.loc[orden['Hora'] == time(14,30,0), 'Numero'].values[0]
            agentes[posicion] = agentes[posicion] - 1

                # Actualizo los arrays contestadas, accesibilidad, accesibilidad_dia y acc y actualizo las columnas Subturno y Hora del dataframe planning

            contestadas = agentes * productividad
            contestadas = np.minimum(contestadas,forecast) * tope_accesibilidad
            accesibilidad = np.nan_to_num(np.divide(contestadas, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
            accesibilidad_dia = np.sum(contestadas) / np.sum(forecast) * 100
            acc = pd.DataFrame(np.random.randn(30,2), columns=['Hora','Accesibilidad'])
            acc.iloc[:,0] = horas
            acc.iloc[:,1] = accesibilidad
            planning.loc[planning['Nombre'] == nombre, 'Lunch'] = time(14, 30, 0)
            

                # Actualizo breaks
            planning.loc[planning['Nombre'] == nombre, 'Break1'] = time(16,50,0)
            planning.loc[planning['Nombre'] == nombre, 'Break2'] = time(19,40,0)


    
    # Pongo Lunch+ y Lunch++
    
    for i in range(len(planning['Nombre'])):
        if planning.loc[i, 'Lunch'] != 0 and planning.loc[i,'Subturno'] != 'M7.0.2' and planning.loc[i,'Subturno'] != 'T14.0.2':
            planning.loc[i, 'Lunch2'] = (datetime.combine(datetime.today(), planning.loc[i, 'Lunch']) + timedelta(minutes=10)).time()
            planning.loc[i, 'Lunch3'] = (datetime.combine(datetime.today(), planning.loc[i, 'Lunch']) + timedelta(minutes=20)).time()




    planning2 = pd.melt(planning, id_vars=['Línea', 'Nombre',dia,'Agente', 'Preferencia', 'Pref. Texto', 'Subturno'], var_name='Tipo de pausa', value_name='Hora')
    planning2['Pais'] = ['ALEMANIA'] * len(planning2['Nombre'])
    planning2['Dia'] = [dia] * len(planning2['Nombre'])

    definitivo = pd.concat([definitivo, planning2], ignore_index=True)

    auxprevision = {'Dia': [],
         'Pais': [],
         'Hora': [],
         'Agentes': [],
         'Productividad': [],
         'Contestadas': [],
         'Recibidas': [],
         'Accesibilidad sin limitar': [],
         'Accesibilidad limitada': []}

    auxprevision = pd.DataFrame(auxprevision)

    auxprevision['Hora'] = acc['Hora']
    auxprevision['Accesibilidad limitada'] = acc['Accesibilidad']
    auxprevision['Dia'] = [dia] * len(auxprevision['Hora'])
    auxprevision['Pais'] = ['ALEMANIA'] * len(auxprevision['Hora'])
    auxprevision['Accesibilidad sin limitar'] = np.nan_to_num(np.divide(agentes * productividad, forecast, out=np.zeros_like(contestadas), where=(forecast != 0)) * 100)
    auxprevision['Agentes'] = agentes
    auxprevision['Productividad'] = [productividad] * len(auxprevision['Hora'])
    auxprevision['Contestadas'] = contestadas
    auxprevision['Recibidas'] = forecast

    prevision = pd.concat([prevision,auxprevision], ignore_index = True)

    print(dia)
    print(planning)


    return definitivo, prevision




diferencia = fin - inicio
diferencia = diferencia.days + 1

for i in range(diferencia):
    definitivo, prevision = pausas(inicio + timedelta(days=i),planning,definitivo,prevision)

columnas_a_concatenar = definitivo.iloc[:, 11:]

definitivo['Turnos'] = columnas_a_concatenar.apply(lambda row: ' '.join(str(cell) for cell in row if pd.notna(cell)), axis=1)
definitivo.drop(definitivo.columns[11:-1],axis=1,inplace=True)
definitivo.drop(definitivo.columns[2],axis=1,inplace=True)


definitivo.to_excel('Pausas_limpio.xlsx',index=False)
prevision.to_excel('Prevision_limpio.xlsx', index=False)
